**文本更新于 2020年04月16日 17:49:57**
## 简介
- [题目链接](https://leetcode-cn.com/problems/01-matrix/submissions/)

题目要求的是曼哈顿距离。
## 解法一 - 暴力法
暴力法。
我们一一遍历矩阵中元素：
  - 如果元素值为 0，则距离得出为 0
  - 如果元素值不为 0，则对该元素位置进行 bfs，找出最短距离。

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
    if(!matrix.length || !matrix[0].length) return null;

    let n = matrix.length;
    let m = matrix[0].length;
    let ans = new Array(n);
    for(let i = 0; i < n; i++) ans[i] = new Array(m).fill(-1);

    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++) {
            if(matrix[i][j] === 0) ans[i][j] = 0;
            else ans[i][j] = bfs(i, j);
        }

    return ans;

    function bfs(row, col) {
        let queue = [[row, col]];
        let visited = new Array(n);
        let dist = 0;
        for(let i = 0; i < n; i++) visited[i] = new Array(m).fill(false);
        visited[row][col] = true;
        while(queue.length) {
            let len = queue.length;
            dist++;
            for(let i = 0; i < len; i++) {
                let top = queue.shift();

                if(top[0] + 1 < n && !visited[top[0]+1][top[1]]) {
                    if(matrix[top[0]+1][top[1]] === 0) return dist;
                    queue.push([top[0]+1, top[1]]);
                    visited[top[0]+1][top[1]] = true;
                }
                if(top[0] - 1 >= 0 && !visited[top[0]-1][top[1]]) {
                    if(matrix[top[0]-1][top[1]] === 0) return dist;
                    queue.push([top[0]-1, top[1]]);
                    visited[top[0]-1][top[1]] = true;
                }
                if(top[1] + 1 < m && !visited[top[0]][top[1]+1]) {
                    if(matrix[top[0]][top[1]+1] === 0) return dist;
                    queue.push([top[0], top[1]+1]);
                    visited[top[0]][top[1]+1] = true;
                }
                if(top[1] - 1 >= 0 && !visited[top[0]][top[1]-1]) {
                    if(matrix[top[0]][top[1]-1] === 0) return dist;
                    queue.push([top[0], top[1]-1]);
                    visited[top[0]][top[1]-1] = true;
                }
            }
        }
    }
};
```

**复杂度分析**:
- 时间复杂度：$O(N^2*M^2)$，$N$ 是行数，$M$ 是列数
- 空间复杂度：$O(N*M)$


## 解法二 - 多源 BFS
解法一的时间复杂度过高。很明显本题可以转化成对于从所有值为0的点同时向外扩散的时间（速度为 1 格/次），求当扩散到矩阵中所有点的时间。

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var updateMatrix = function(matrix) {
    if(!matrix.length || !matrix[0].length) return null;

    let n = matrix.length;
    let m = matrix[0].length;
    let ans = new Array(n);
    for(let i = 0; i < n; i++) ans[i] = new Array(m).fill(-1);

    let queue = [];
    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++) {
            if(matrix[i][j] === 0) {
                ans[i][j] = 0;
                queue.push([i, j]);
            }
        }

    let dist = 0;
    while(queue.length) {
        let len = queue.length;
        dist++;
        for(let i = 0; i < len; i++) {
            let top = queue.shift();

            if(top[0] + 1 < n && ans[top[0]+1][top[1]] === -1) {
                queue.push([top[0]+1, top[1]]);
                ans[top[0]+1][top[1]] = dist;
            }
            if(top[0] - 1 >= 0 && ans[top[0]-1][top[1]] === -1) {
                queue.push([top[0]-1, top[1]]);
                ans[top[0]-1][top[1]] = dist;
            }
            if(top[1] + 1 < m && ans[top[0]][top[1]+1] === -1) {
                queue.push([top[0], top[1]+1]);
                ans[top[0]][top[1]+1] = dist;
            }
            if(top[1] - 1 >= 0 && ans[top[0]][top[1]-1] === -1) {
                queue.push([top[0], top[1]-1]);
                ans[top[0]][top[1]-1] = dist;
            }
        }
    }
    return ans;

};
```
**复杂度分析**:
- 时间复杂度：$O(N*M)$，$N$ 是行数，$M$ 是列数
- 空间复杂度：$O(N*M)$

### 解法三 - 动态规划
因为矩阵中肯定有一个 0。那么对于任意一个 1 来讲，距离最近的 0 可能在 4 个区域：
- 左上
- 右上
- 左下
- 右下

那么从该 1 的位置走到该 0 可能有四种走法：
- 只有水平向左移动 和 竖直向上移动
- 只有水平向右移动 和 竖直向上移动
- 只有水平向左移动 和 竖直向下移动
- 只有水平向右移动 和 竖直向下移动

则我们可以得出四个转移方程：
$$
f(i, j) = 
\begin{cases}
1 + min(f(i-1, j), f(i, j-1)) , 位置 (i,j) 值为 1\\
0, 位置值为 0
\end{cases}
$$

另外三个就不写了，同理即可。

```javascript
var updateMatrix = function(matrix) {
    if(!matrix.length || !matrix[0].length) return null;

    let n = matrix.length;
    let m = matrix[0].length;
    let ans = new Array(n);
    for(let i = 0; i < n; i++) ans[i] = new Array(m).fill(n+m);

    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++)
            if(matrix[i][j] === 0) ans[i][j] = 0;
    
    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++) {
            if(i-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i-1][j]+1);
            if(j-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i][j-1]+1);
        }
            
    
    for(let i = n-1; i >= 0; i--)
        for(let j = 0; j < m; j++){
            if(i+1 < n) ans[i][j] = Math.min(ans[i][j], ans[i+1][j]+1);
            if(j-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i][j-1]+1);
        }
    
    for(let i = n-1; i >= 0; i--)
        for(let j = m -1 ; j >= 0; j--){
            if(i+1 < n) ans[i][j] = Math.min(ans[i][j], ans[i+1][j]+1);
            if(j+1 < m) ans[i][j] = Math.min(ans[i][j], ans[i][j+1]+1);
        }

    for(let i = 0; i < n; i++)
        for(let j = m -1 ; j >= 0; j--){
            if(i-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i-1][j]+1);
            if(j+1 < m) ans[i][j] = Math.min(ans[i][j], ans[i][j+1]+1);
        }
    return ans;

};
```

**复杂度分析**:
- 时间复杂度：$O(5*N*M) = O(N*M)$，$N$ 是行数，$M$ 是列数
- 空间复杂度：$O(1)$


### 解法四 - 动态规划优化
在解法三中，我们遍历了 4 遍，这里面仍然有不少重复的计算。
其实我们只需要 2 遍遍历即可。

- 从左上到右下，再从右下到左上
- 从左下到右上，再从右上到左下

任意选择一种即可。

为何如此呢？
我们先证明一个性质：
假如距离$(i,j)$最近的点在$(i-a,j+b) a>0,b>0$，则距离$(i,j+b)$最近的点在$(i-a,j+b)$。

 用反证法证明： 如果距离$(i,j+b)$最近的点$(x,y)$不在$(i-a,j+b)$，则$(i,j+b)$和$(x,y)$距离$d<a$，这时点$(i,j)$和$(x,y)$的距离$d'<=b+d<a+b$,与假设矛盾。 

 利用这个性质：
 - 如果距离 $(i, j)$ 的点最近点在 $(i-a,j+b) a>0,b>0$，我们在从左上到右下的遍历就可以得出其值。
 - 如果最近点在 $(i+a, j+b), a>0,b>0$, 我们可以在从右下到左上的这次遍历中可以得出其值。为什么？同上面证明，$(i+a, j)$的最近点和 $(i, j)$ 一致
 - 另外两个象限同理

```javascript
var updateMatrix = function(matrix) {
    if(!matrix.length || !matrix[0].length) return null;

    let n = matrix.length;
    let m = matrix[0].length;
    let ans = new Array(n);
    for(let i = 0; i < n; i++) ans[i] = new Array(m).fill(n+m);

    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++)
            if(matrix[i][j] === 0) ans[i][j] = 0;
    
    for(let i = 0; i < n; i++)
        for(let j = 0; j < m; j++) {
            if(i-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i-1][j]+1);
            if(j-1 >= 0) ans[i][j] = Math.min(ans[i][j], ans[i][j-1]+1);
        }
            
    
    
    for(let i = n-1; i >= 0; i--)
        for(let j = m -1 ; j >= 0; j--){
            if(i+1 < n) ans[i][j] = Math.min(ans[i][j], ans[i+1][j]+1);
            if(j+1 < m) ans[i][j] = Math.min(ans[i][j], ans[i][j+1]+1);
        }

    return ans;

};
```
**复杂度分析**:
- 时间复杂度：$O(3*N*M) = O(N*M)$，$N$ 是行数，$M$ 是列数
- 空间复杂度：$O(1)$