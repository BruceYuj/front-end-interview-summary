**文本更新于 2020年06月 4日 17:34:27**
## 简介
- [1130. 叶值的最小代价生成树](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values/)

## 解法一 - 动态规划
根据题意可以知道，二叉树中的结点要么是叶子结点，要么是有 2 个子结点。

假设数组为 $arr[0,...,n-1]$, 则非叶子结点的最小可能总和为所有切割可能的最小值（按照切割点形成左右子树，且左右子树不能为空）

这里假设 $dp[i][j]$ 为 $arr[i,...,j]$ 的最小可能总和，则 $dp[0][n-1] = min(dp[0][k] + dp[k+1][n-1] + max(arr[0, ..., k], arr[k+1,...,n-1]))$

对于 $max(arr[0,...,k], arr[k+1,...,n-1]$，我们可以预先求出所有的 $max(arr[i,...j])$，时间复杂度为 $O(n^2)$

对于只有一个结点，也就是$dp[i][i] = 0$，因为一个结点只能是叶子结点，所以不算在总和里。

```javascript
/**
 * @param {number[]} arr
 * @return {number}
 */
var mctFromLeafValues = function(arr) {
    let n = arr.length;
    let dp = new Array(n);
    let maxVal = new Array(n);

    for(let i = 0; i < n; i++) {
        maxVal[i] = new Array(n).fill(0);
        dp[i] = new Array(n).fill(Infinity);
        dp[i][i] = 0;
    }

    for(let i = 0; i < n; i++) {
        maxVal[i][i] = arr[i];
        for(let j = i+1; j < n; j++) {
            maxVal[i][j] = Math.max(arr[j], maxVal[i][j-1]);
        }
    }

    for(let len = 1; len < n; len++) {
        for(let s = 0; s + len < n; s++) {
            for(let k = s; k < s+len; k++) {
                dp[s][s+len] = Math.min(dp[s][s+len], dp[s][k] + dp[k+1][s+len] + maxVal[s][k] * maxVal[k+1][s+len]);
            }
        }
    }

    return dp[0][n-1];
};
```
**复杂度分析**:
- 时间复杂度：$O(n^3)$
- 空间复杂度：$O(n^2)$