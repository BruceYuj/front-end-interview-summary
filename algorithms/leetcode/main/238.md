**文本更新于 2020年06月 4日  9:29:44**
## 简介
- [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

## 解法一 - 左右乘积缓存
由于不能使用除法，对于任意一个位置 $i$，它的结果应该是 $i$ 左边所有的值乘积乘以 $i$ 右边所有值的乘积。

而所有位置的左积和右积可以累计计算。

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    
    let n = nums.length;

    let left = new Array(n);
    let right = new Array(n);
    let ans = [];
    left[0] = 1;
    right[n-1] = 1; 
    for(let i = 1; i < n; i++) {
        left[i] = left[i-1] * nums[i-1];
        right[n-i-1] = right[n-i] * nums[n-i];
    }

    for(let i = 0; i < n; i++) {
        ans[i] = left[i] * right[i];
    }

    return ans;
};
```
**复杂度分析**

- 时间复杂度：$O(N)$，$N$ 是数组的长度。
- 空间复杂度：$O(N)$，$N$ 是数组的长度。


### 空间优化
我们可以将左积和右积的计算融入到最后答案的计算中（实时计算），而不是做缓存。

```javacript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    
    let n = nums.length;

    let left = 1;
    let right = 1;
    let ans = [];

    for(let i = 0; i < n; i++) {
        ans[i] = left;
        left = left * nums[i];
    }

    for(let i = n-1; i >= 0; i--) {
        ans[i] *= right;
        right = right * nums[i];
    }

    return ans;
};
```

**复杂度分析**

- 时间复杂度：$O(N)$，$N$ 是数组的长度。
- 空间复杂度：$O(1)$，$N$ 是数组的长度。