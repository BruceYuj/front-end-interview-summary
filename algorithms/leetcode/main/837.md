**文本更新于 2020年06月 3日 10:21:13**
## 简介
- [837. 新21点](https://leetcode-cn.com/problems/new-21-game/)

## 动态规划
假设 $dp[i]$ 是以 $i$ 分开始获得胜利的概率。
因此，我们先将 $i$ 分成两种情况：
1. $i \geq k$ 时：
   - 如果 $i > N$，则 $dp[i] = 0$
   - 如果 $i \leq min(N, K-1+W)$，则 $dp[i] = 1$
2. $i < k$ 时：$dp[i] = \frac{dp[i+1] + ... + dp[i+k]}{W}$(因为是独立随机分布的)

```javascript
var new21Game = function(N, K, W) {

    let dp = new Array(K+W).fill(0);

    for(let i = K; i <= N && i <= K+W-1; i++) dp[i] = 1;

    for(let i = K-1; i >= 0; i--){
        let tmp = 0;
        for(let j = 1; j <= W; j++) {
            tmp += dp[i+j];
        }

        dp[i] = tmp / W;
    }

    return dp[0];

};
```
**复杂度分析**：
- 时间复杂度：$O(N+KW)$
- 空间复杂度：$O(K+W)$

## 动态规划的优化
当 $i < K$ 时，在计算 $dp[i+1]+...+dp[i+W]$ 时会有很多重复计算。

我们通过差分可以发现：
当 $0 \leq x < K-1$ 时，$dp[x] - dp[x+1] = \frac{dp[x+1] - dp[x+W+1]}{W}$

这样可以得到新的转移方程：
$dp[x]  = dp[x+1] + \frac{dp[x+1] - dp[x+W+1]}{W}$

剩下一个 $i= K-1$ 时，
$dp[K-1] = \frac{dp[K]+...+dp[K+W-1]}{W} = \frac{min(N, K+W-1) - K+1}{W} = \frac{min(N-K+1, W)}{W}$，也就可以在 $O(1)$  求出 $dp[K-1]$

```javascript
/**
 * @param {number} N
 * @param {number} K
 * @param {number} W
 * @return {number}
 */
var new21Game = function(N, K, W) {

    let dp = new Array(K+W).fill(0);

    for(let i = K; i <= N && i <= K+W-1; i++) dp[i] = 1;

    dp[K-1] = Math.min(N-K+1, W) / W;
    
    for(let i = K-2; i >= 0; i--){
        dp[i] = dp[i+1] + (dp[i+1] - dp[W+i+1])/W;
    }

    return dp[0];

};
```
**复杂度分析**：
- 时间复杂度：$O(min(N, K+W))$
- 空间复杂度：$O(K+W)$