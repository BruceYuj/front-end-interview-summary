(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{434:function(t,v,e){t.exports=e.p+"assets/img/http-request-method-1.a17abced.jpg"},435:function(t,v,e){t.exports=e.p+"assets/img/http-request-method-2.f6ccbde5.png"},501:function(t,v,e){"use strict";e.r(v);var _=e(27),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"脑图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#脑图"}},[t._v("#")]),t._v(" 脑图")]),t._v(" "),_("p",[_("img",{attrs:{src:e(434),alt:""}})]),t._v(" "),_("p",[t._v("目前主流使用的 HTTP 协议的请求方法是比较固定的，并没有随着大版本的提升有过多改变。")]),t._v(" "),_("p",[_("img",{attrs:{src:e(435),alt:""}})]),t._v(" "),_("p",[t._v("按照 "),_("strong",[t._v("常用、非常用以及扩展")]),t._v(" 可以分成上图中的 3 类。要彻底掌握这些 request methods，我们需要从几方面问题来考虑：")]),t._v(" "),_("ol",[_("li",[t._v("该 请求方法 的设计初衷是什么？")]),t._v(" "),_("li",[t._v("在目前实践中和最初的设计有变化吗？目前通常的用途有哪些？")])]),t._v(" "),_("h2",{attrs:{id:"安全与幂等"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全与幂等"}},[t._v("#")]),t._v(" 安全与幂等")]),t._v(" "),_("p",[t._v("首先，得理解一下 HTTP 协议中的安全和幂等的概念：")]),t._v(" "),_("ul",[_("li",[t._v("“安全”是指请求方法不会 “破坏” 服务器上的资源,即不会对服务器上的资源造成实质的修改。")]),t._v(" "),_("li",[t._v("“幂等”是多次执行相同的操作,结果也都是相同的, 即多次“幂”后结果“相等”，和数学中的概念异曲同工。")])]),t._v(" "),_("h2",{attrs:{id:"get-请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get-请求"}},[t._v("#")]),t._v(" GET 请求")]),t._v(" "),_("p",[t._v("GET 请求是 HTTP 协议当中最先出现的请求方法，在 HTTP/0.9 的世界当中，所有的文档都是只读的。")]),t._v(" "),_("p",[t._v("其设计用途是客户端请求获取服务器的资源。在具体的 RFC 7231 当中其有以下几种特性：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("yes")])])])]),t._v(" "),_("p",[_("strong",[t._v("在实际使用当中，搭配 URI 和其他头字段就能实现对资源更精细的操作。")])]),t._v(" "),_("ol",[_("li",[t._v("比如通过 URI 后使用 "),_("code",[t._v("#")]),t._v("，在获取页面后直接定位到标签位置；")]),t._v(" "),_("li",[t._v("结合 "),_("code",[t._v("if-modified-since")]),t._v(" 头字段可以变成有条件的请求；")]),t._v(" "),_("li",[t._v("结合 "),_("code",[t._v("Range")]),t._v(" 头字段表示“范围请求” (具体可以用在请求大文件的部分时)")])]),t._v(" "),_("h2",{attrs:{id:"head-请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#head-请求"}},[t._v("#")]),t._v(" HEAD 请求")]),t._v(" "),_("p",[t._v("可以将 HEAD 看成是 "),_("strong",[t._v("轻量级")]),t._v(" 的 GET 方法。它不会返回实体数据（即使包含 body，也应该被忽略掉），只会传回响应头（元信息）。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("yes")])])])]),t._v(" "),_("p",[_("strong",[t._v("其设计的目的在于节省带宽（导致延迟的原因之一）")]),t._v("。")]),t._v(" "),_("p",[t._v("有什么实际用途呢？")]),t._v(" "),_("ol",[_("li",[t._v("可以用来检查一个大文件是否存在。只要发个 HEAD 请求就可以了,没有必要用 GET 把整个文件都取下来")]),t._v(" "),_("li",[t._v("检查文件是否有最新版本，可以使用 HEAD")])]),t._v(" "),_("h2",{attrs:{id:"post-put"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post-put"}},[t._v("#")]),t._v(" POST/PUT")]),t._v(" "),_("p",[t._v("两个方法都被用来向 URI 指定的资源提交数据，而 post 方法使用频率更高。")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("两者之间的区别是什么呢？")])])]),t._v(" "),_("p",[t._v("从 HTTP 协议设计的初衷来讲， POST 表示的是 “新建 - create” 的含义，而 PUT 则是 “修改 - update” 的含义。换种说法，PUT 方法是幂等的，而 POST 不是幂等的（比如多次提交订单）。")]),t._v(" "),_("p",[_("strong",[t._v("这里需要了解一点，HTTP 协议并不是一个强制协议。也就是说，如果客户端和服务端自己互相协商协议内容（比如乱用请求方法），也是可以的。")])]),t._v(" "),_("h3",{attrs:{id:"post-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post-方法"}},[t._v("#")]),t._v(" POST 方法")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("only if freshness information is included")])])])]),t._v(" "),_("p",[t._v("我们通常有两种方式来使用 POST 方法：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("发送 HTML form，并返回服务器的修改结果("),_("strong",[t._v("这是 POST 最开始的用途，因此那时 form 是网页的重要组成部分")]),t._v(")。此时，body 的类型(content type) 往往通过 form 的 attribute 来决定，往往有下面三种可能：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("application/x-www-form-urlencoded")]),t._v("：从名字就可以看出来，会使用 url 编码的方式。将数据编码成 "),_("code",[t._v("x=y&z=k")]),t._v(" 这种方式。你会发现，这种方式和 GET 方法添加 params 相似。"),_("strong",[t._v("两者之间的区别是什么呢？")]),t._v(" GET 方法直接将 params 在浏览器地址栏中显示出来；而 POST 是放在 body里面的。")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("POST / HTTP/1.1\nHost: foo.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 13\n\nsay=Hi&to=Mom\n")])])]),_("ul",[_("li",[_("code",[t._v("multipart/form-data")]),t._v(":  "),_("code",[t._v("application/x-www-form-urlencoded")]),t._v(" 在处理 ASCII 字符时是没什么问题的。但是实际上在国际化后，网络数据包中充斥着大量的非 ASCII 字符，比如中文。 UTF-8 中的汉字 “中” 是 3 个字节，而 urlencode 之后变成了 9 个字节，对于带宽来讲是忍受不了的，我们更期望于在传输过程中不要无故增大 body 大小（甚至压缩是最好的），这也就是 multipart/form-data 出现的原因。")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('POST /test.html HTTP/1.1 \nHost: example.org \nContent-Type: multipart/form-data;boundary="boundary" \n\n--boundary \nContent-Disposition: form-data; name="field1" \nContent-Type: text/plain\n\nvalue1 \n--boundary \nContent-Disposition: form-data; name="field2"; filename="example.txt" \n\nvalue2\n')])])]),_("p",[t._v("如果仔细观察的话，"),_("code",[t._v("multipart/form-data")]),t._v(" 和 "),_("code",[t._v("multipart/byteranges")]),t._v(" 使用方式很类似。而 RFC 7231 也专门用了 Multipart Types 来指代这两个 MIME 类型。前者一般只被用在 form data 的处理，而后者通常被用在范围请求(一些 206 partial Content 的 response 当中)。")]),t._v(" "),_("p",[_("strong",[t._v("有人会好奇 boundary 的含义和为什么每一段都会有对应的头字段(比如 content-type)?")])]),t._v(" "),_("p",[t._v("顾名思义， boundary 就是边界的意思，用来分隔不同段之间的内容。而每一段都有对应头字段是由于 RFC 规范需要考虑很多特殊情况，它会考虑到如果传输多个内容并且内容编码方式不一样的情况，所以设计了对应的头字段。在实际使用当中，我们可以使用也可以不使用。")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("text/palin")]),t._v(": 就是字面意思。")])])]),t._v(" "),_("li",[_("p",[t._v("第二种方式是通过 "),_("code",[t._v("XMLHttpRequest")]),t._v(" 来使用 POST 请求。")])])]),t._v(" "),_("blockquote",[_("p",[t._v("这里需要注意的是，XMLHttpRequest 并不是 HTTP 协议定义的，而是由 WAHTWG 社区维护的。")])]),t._v(" "),_("p",[t._v("在使用 XHR 来进行 POST 请求时， body 的类型可以是 HTTP 中规定的任意类型。正如 HTTP 1.1 规范所设计的那样，期望 POST 以统一的方式来完成以下几种功能：")]),t._v(" "),_("ul",[_("li",[t._v("已存在资源的注解(annotation)")]),t._v(" "),_("li",[t._v("在各种网页上发布消息（这是网页的主要功能之一）")]),t._v(" "),_("li",[t._v("注册新用户")]),t._v(" "),_("li",[t._v("向数据处理程序提供数据，比如提交表单")]),t._v(" "),_("li",[t._v("通过追加操作，扩展数据库数据")])]),t._v(" "),_("h3",{attrs:{id:"put-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#put-方法"}},[t._v("#")]),t._v(" PUT 方法")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("No")])])])]),t._v(" "),_("p",[t._v("除了上面我们所说的 PUT 方法是幂等的，另外区别是 PUT 方法不会出现在 HTML form 当中，并且不可缓存。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("PUT /new.html HTTP/1.1\nHost: example.com\nContent-type: text/html\nContent-length: 16\n\n<p>New File</p>\n")])])]),_("p",[t._v("那么对于 PUT 请求的 response 来讲，有哪些细节呢？")]),t._v(" "),_("ol",[_("li",[t._v("如果目标资源不存在，并且 PUT 方法成功创建了一份，那么 response 的状态码必须是 "),_("code",[t._v("201(created)")]),t._v(" 来通知客户端资源已创建。")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("HTTP/1.1 201 Created\nContent-Location: /new.html\n")])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("如果资源已存在，但是通过 PUT 方法成功进行了更新，那么服务器必须返回 "),_("code",[t._v("200")]),t._v(" 或者 "),_("code",[t._v("204(No Content)")]),t._v(" 来表示请求成功。")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("HTTP/1.1 204 No Content\nContent-Location: /existing.html\n")])])]),_("h2",{attrs:{id:"delete方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#delete方法"}},[t._v("#")]),t._v(" DELETE方法")]),t._v(" "),_("p",[t._v("用来指示服务器删除资源。这在 RESTful 风格的架构中被使用很多。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("可能有")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("可能有")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("no")])])])]),t._v(" "),_("p",[t._v("如果 DELETE 方法执行成功，可能有以下的状态码：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("202(Accepted)")]),t._v(": 表示请求操作可能会成功执行，但是尚未开始执行")]),t._v(" "),_("li",[_("code",[t._v("204(No Content)")]),t._v("： 表示操作已执行，但是没有进一步相关信息")]),t._v(" "),_("li",[_("code",[t._v("200(ok)")]),t._v(": 表示操作已执行，response 中提供了相关状态信息")])]),t._v(" "),_("h2",{attrs:{id:"connect-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#connect-方法"}},[t._v("#")]),t._v(" CONNECT 方法")]),t._v(" "),_("p",[t._v("CONNECT 方法在实际的网页开发中使用很少。但是，需要注意一点的是，HTTP 并不仅仅只是一个“网页”协议，它的功能非常强大。")]),t._v(" "),_("p",[t._v("该方法的主要作用 - HTTP 代理（敏感原因，不能多聊），简单来讲，就是要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道,这时 Web 服务器在中间充当了代理的角色。")]),t._v(" "),_("p",[t._v("CONNECT 方法直接通过 TCP 进行和代理服务器的连接，如下所示：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("CONNECT www.xxx.com:80 HTTP/1.1\nHost: www.web-tinker.com:80\nProxy-Connection: Keep-Alive\nProxy-Authorization: Basic *\nContent-Length: 0\n")])])]),_("p",[_("code",[t._v("Proxy-Authorization")]),t._v(" 用来验证。")]),t._v(" "),_("p",[t._v("具体想要将 HTTP 代理运用在实际当中，就牵扯到相关的加密等操作了，不敢多讲。")]),t._v(" "),_("h2",{attrs:{id:"options-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#options-方法"}},[t._v("#")]),t._v(" OPTIONS 方法")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("值")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("request 是否有 body")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("resposne 是否有 body")]),t._v(" "),_("td",[t._v("no")])]),t._v(" "),_("tr",[_("td",[t._v("安全")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("幂等")]),t._v(" "),_("td",[t._v("yes")])]),t._v(" "),_("tr",[_("td",[t._v("可缓存")]),t._v(" "),_("td",[t._v("no")])])])]),t._v(" "),_("p",[t._v("在最开始的设计当中，OPTIONS 方法被用来要求服务器列出可对资源实行的操作方法, 并且在响应头的 Allow 字段里返回。\n"),_("code",[t._v("curl -X OPTIONS http://example.com -i")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("HTTP/1.1 200 OK\nAllow: OPTIONS, GET, HEAD, POST\nCache-Control: max-age=604800\nDate: Thu, 13 Oct 2016 11:45:00 GMT\nExpires: Thu, 20 Oct 2016 11:45:00 GMT\nServer: EOS (lax004/2813)\nx-ec-custom-error: 1\nContent-Length: 0\n")])])]),_("p",[t._v("后来，随着 CORS 机制的出现，浏览器会使用 OPTIONS 方法发预检请求。具体 CORS 是如何使用 OPTIONS 方法的，会另起一篇文章再谈。")]),t._v(" "),_("h2",{attrs:{id:"trace方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#trace方法"}},[t._v("#")]),t._v(" TRACE方法")]),t._v(" "),_("p",[t._v("TRACE 方法是 HTTP 协议提供的一种 debug 方式，用于对 HTTP 链路的测试或诊断,可以显示出请求 - 响应的传输路径(loop-back test)，在实际开发当中使用并不多。")]),t._v(" "),_("h2",{attrs:{id:"扩展方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩展方法"}},[t._v("#")]),t._v(" 扩展方法")]),t._v(" "),_("p",[t._v("常用的 HTTP 扩展方法有 MKCOL、COPY、MOVE、LOCK、UNLOCK、PATCH 等。也就是说，它不是出现在具体的 HTTP 协议内容里面的。往往是由于各大应用厂商先自己扩展，然后广泛应用到业界，IETF 看到已经成为事实约定了，就补充这些相关的方法。")]),t._v(" "),_("h3",{attrs:{id:"patch-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#patch-方法"}},[t._v("#")]),t._v(" PATCH 方法")]),t._v(" "),_("p",[t._v("PATCH 方法是对 PUT/POST 方法的补充，用于对资源进行部分的修改，是非幂等的。"),_("a",{attrs:{href:"https://tools.ietf.org/html/rfc5789",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC5789"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("首先，我们需要判断一台服务器是否支持 PATCH 方法：")]),t._v(" "),_("ol",[_("li",[t._v("通过字段 Allow 或 Access-Control-Allow-Methods 查看")]),t._v(" "),_("li",[t._v("看是否出现 Accept-Patch")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('PATCH /file.txt HTTP/1.1 \nHost: www.example.com\nContent-Type: application/example\nIf-Match: "e0023aa4e"\nContent-Length: 100\n\n[description of changes]\n')])])]),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('HTTP/1.1 204 No Content\nContent-Location: /file.txt\nETag: "e0023aa4f"\n')])])])])}),[],!1,null,null,null);v.default=a.exports}}]);