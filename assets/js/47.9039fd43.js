(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{489:function(v,_,e){"use strict";e.r(_);var t=e(27),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"浏览器的趋势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的趋势"}},[v._v("#")]),v._v(" 浏览器的趋势")]),v._v(" "),e("ol",[e("li",[v._v("应用程序 Web 化：云计算和 H5 技术快速发展，很多应用转向 B/S 架构")]),v._v(" "),e("li",[v._v("Web 应用移动化：开发方便，移动端通过 webview 开发应用，PWA 期望解决 web 和原生应用各自优势")]),v._v(" "),e("li",[v._v("Web 操作系统化\n"),e("ul",[e("li",[v._v("chromeOS，利用 web 技术构建纯粹的操作系统")]),v._v(" "),e("li",[v._v('浏览器底层结构往操作系统架构方向发展。也就是成为操作系统上面的 "OS"\n'),e("ul",[e("li",[v._v("也就是朝着 SOA（面向服务的架构），更多模块以服务形式提供给上层使用")]),v._v(" "),e("li",[v._v("引入 assembly，支持多种编程语言")]),v._v(" "),e("li",[v._v("简化渲染流程")]),v._v(" "),e("li",[v._v("加大对系统设备特性支持")]),v._v(" "),e("li",[v._v("支撑复杂 web 项目的开发")])])])])])]),v._v(" "),e("h2",{attrs:{id:"浏览器的占比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的占比"}},[v._v("#")]),v._v(" 浏览器的占比")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://gs.statcounter.com/browser-market-share/",target:"_blank",rel:"noopener noreferrer"}},[v._v("statcounter"),e("OutboundLink")],1)]),v._v(" "),e("p",[v._v("目前来讲， Chrome 、Edge 和国内大部分主流浏览器都是基于 Chromium 二次开发而来。\n总体来讲：")]),v._v(" "),e("ol",[e("li",[v._v("global：\n"),e("ul",[e("li",[v._v("chrome 占 62%，safari 占 20%")])])]),v._v(" "),e("li",[v._v("china:\n"),e("ul",[e("li",[v._v("chrome 接近一半，UC 和 QQ 加起来 22%，safari 10%")])])])]),v._v(" "),e("h2",{attrs:{id:"学习浏览器工作原理原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#学习浏览器工作原理原因"}},[v._v("#")]),v._v(" 学习浏览器工作原理原因")]),v._v(" "),e("ol",[e("li",[v._v("准确评估 web 项目可行性")]),v._v(" "),e("li",[v._v("更高维度审视页面性能，更好理解最佳实践")]),v._v(" "),e("li",[v._v("把握快节奏技术迭代中的本质")])]),v._v(" "),e("h2",{attrs:{id:"主流浏览器的排版引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主流浏览器的排版引擎"}},[v._v("#")]),v._v(" 主流浏览器的排版引擎")]),v._v(" "),e("ol",[e("li",[v._v("Chrome：Blink，由webkit分支中的 webCore 独立出来")]),v._v(" "),e("li",[v._v("Safari：Webkit 中的 webcore，webkit包含 webcore 和 JavaScriptCore（JS engine）")]),v._v(" "),e("li",[v._v("Firefox：Gecko")])]),v._v(" "),e("p",[v._v("三个排版引擎(layout engine)的渲染流水线类似，但是具体实现差别比较大。")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/guanghe/p/5948415.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("更多简介"),e("OutboundLink")],1)]),v._v(" "),e("h2",{attrs:{id:"chrome-的多进程架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome-的多进程架构"}},[v._v("#")]),v._v(" chrome 的多进程架构")]),v._v(" "),e("p",[v._v("在2008年,chrome 提出多进程架构基本出于以下几点原因：")]),v._v(" "),e("ol",[e("li",[v._v("webkit 属于 apple，公司之间的信任问题")]),v._v(" "),e("li",[v._v("webkit在当时很多内存泄露，多进程能够很大程度避免。因为一个进程关了，所有该进程的内存会被回收")]),v._v(" "),e("li",[v._v("安全性更好。单进程多线程在于共享内存空间导致隔离不足，bug很容易扩散，可能导致全面崩溃。而多进程架构强制要求 IPC 通信，类似于开启了进程间防火墙。")]),v._v(" "),e("li",[v._v("webkit当时很多全局变量，如果一个页面一个线程理论上不好搞。最开始有考虑过单进程多线程模式，后来被舍弃。不过该方案在移动端有优势（基于手机性能和内存原因），因此最开始 android chromium 就是单进程模式（现在是多进程）。")]),v._v(" "),e("li",[v._v("传统的浏览器被设计为显示网页，而Chrome的设计目标是支撑“web app”（当时js和相关技术已经很发达，并且Gmail等服务很成功）。这就需要Chrome 提供一个类似于OS的架构，支持复杂APP的运行。而如果 APP变得复杂，就难以避免出现bug，然后 crash。同时浏览器可能面临恶意代码，浏览器需要考虑恶意代码是否会攻击浏览器的渲染引擎。因此单进程的架构不太满足要求。")])]),v._v(" "),e("p",[v._v("因此，Chrome将"),e("strong",[v._v("隔离性")]),v._v("作为基本的设计原则，用进程的隔离性来实现对APP隔离：")]),v._v(" "),e("ul",[e("li",[v._v("一个 web app crash 不会导致其他所有的 web app crash（稳定性）")]),v._v(" "),e("li",[v._v("一个web app 可以以某种形式访问其他APP数据（安全性）")]),v._v(" "),e("li",[v._v("web app 之间是并行的，可以提供更好响应（性能），这个多线程也能做到")])]),v._v(" "),e("blockquote",[e("p",[v._v("也就是更多的工程思维的方式问题。初级者可能直觉上认为 thread 比 process更加高级、轻量、性能也更好，所以应该使用多线程。但是架构师会思考：想解决的是复杂系统的安全和错误处理。最好的方式就是严格隔离。而实现隔离的最自然方式是用多进程。但是多进程有一些问题，所以我们保证我们这么设计的同时能够最大程度避免这些问题。也就是说，我们要抓住问题的核心，然后围绕核心方案再去考虑一些小问题。\n另外是处理错误的方式。一般开发者认为稳定性是要兜底，保证出现问题时程序能够继续运行，只要不挂就可以。但是这是有使用场景的。因为某些异常做出的事是程序无法控制的，比如乱写磁盘文件，乱发非法请求。而这是浏览器无法接受的，因此一旦出现这类问题，crash它就是最好方法。这些是window 蓝屏或者 ios app 闪退考虑的处理因素之一。高可靠的系统需要把高度危险和不可控非常高的部分隔离出去。Erlang将这个设计理念完全纳入了语言和OTP的设计中。")])]),v._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://blog.chromium.org/2008/09/multi-process-architecture.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("chrome multi-process architecture,08"),e("OutboundLink")],1)]),v._v(" "),e("li",[e("a",{attrs:{href:"https://www.chromium.org/developers/design-documents",target:"_blank",rel:"noopener noreferrer"}},[v._v("chrome design document"),e("OutboundLink")],1)])]),v._v(" "),e("p",[v._v("单进程真的比多进程有性能优势吗？（前提是页面不多不复杂的时候）")]),v._v(" "),e("blockquote",[e("p",[v._v("理论上来讲，性能会有些许优势。但是你站在更高的角度上这些性能损耗是微不足道的。")])]),v._v(" "),e("p",[v._v("另外对于现代计算机来讲，往往都是多CPU多核或者单CPU多核的。线程的效率并不一定比进程高。")]),v._v(" "),e("h2",{attrs:{id:"chrome-中的进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome-中的进程"}},[v._v("#")]),v._v(" chrome 中的进程")]),v._v(" "),e("blockquote",[e("p",[v._v("仅仅打开了一个页面，为什么产生 4 个进程？")])]),v._v(" "),e("p",[v._v("我们可以通过 chrome 的"),e("strong",[v._v("任务管理器")]),v._v("看到具体的浏览器任务以及对应的进程信息。")]),v._v(" "),e("h3",{attrs:{id:"进程与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[v._v("#")]),v._v(" 进程与线程")]),v._v(" "),e("p",[v._v("理论上讲，一个进程就是一个程序的运行实例。启动程序时，OS 会给该程序分配一块内存（存放代码、运行中数据和一个执行任务的主线程）。")]),v._v(" "),e("p",[v._v("而通常讲, process 是 cpu 资源分配的最小单位，而线程是 CPU 调度的最小单位。概括的讲，进程和线程都是对CPU工作时间段的描述。")]),v._v(" "),e("p",[v._v("该怎么理解呢？\n对于冯洛伊曼体系来讲，计算由 “CPU+存储+输入输出” 构成。对于用户需求来讲，多任务的需求是随处可见的。比如边工作边听音乐。如何做到多任务呢？")]),v._v(" "),e("ol",[e("li",[v._v("物理层面上\n早期 CPU 是单核的，也就是同一时间 CPU 只能够执行一条指令。")])]),v._v(" "),e("blockquote",[e("p",[v._v("一个常见的经验之谈-“摩尔定律”，每隔一年半到两年，同样钱能够买到的计算力能够翻一倍。")])]),v._v(" "),e("p",[v._v("早期 CPU 的工艺发展，基本上是通过提高电子元器件的密集程度实现的，比如芯片厂商常说的 14nm 工艺，10nm 工艺。但是我们都知道，电子元器件大小是有极限的，越往下越难以突破。")]),v._v(" "),e("p",[v._v("不能更小的话，我们就横向扩展，一个 CPU 多个核心。这样就产生了多核技术。因此物理层面上的多任务有两个方法：")]),v._v(" "),e("ul",[e("li",[v._v("多颗 cpu")]),v._v(" "),e("li",[v._v("单颗 CPU 多核")])]),v._v(" "),e("p",[v._v("目前来讲，普通用户的产品（比如个人计算机、手机、智能手表等）会更在意产品的体积（希望更小一些），因此选择单 CPU 多核模式。\n对于服务器领域，会使用两者的结合，更多关注如何提升单台服务器的计算能力。")]),v._v(" "),e("p",[v._v("但是回到最开始，对于单核的 CPU，我们该如何能够满足多任务的要求呢？\n因此，操作系统将 CPU的时间切成一段段时间片，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。只要时间片足够小，我们就会感觉这些软件在同时运行。（另外一种就是动画是如何通过一张张图片切换产生的，同样是利用人类感官的局限性）。")]),v._v(" "),e("p",[v._v("这种分时间片的多任务系统被称为分时系统（time-sharing system）。其原理就是保存当前任务状态，切换到另外一个任务并恢复该任务，把CPU执行权交给该任务。")]),v._v(" "),e("ul",[e("li",[v._v("什么是任务？如何抽象这个概念？")]),v._v(" "),e("li",[v._v("任务的状态有什么？如何保存和恢复？")]),v._v(" "),e("li",[v._v("什么时候进行任务切换？")])]),v._v(" "),e("p",[v._v("目前的计算机领域发展来看，任务的抽象不是唯一的。大部分 OS 会提供两套：Process 和 Thread。另外有的还会提供 coroutine。有人将其统一称为执行体（被 CPU 赋予执行权的对象）。执行体需要包含下一步执行位置以及运行状态。")]),v._v(" "),e("p",[v._v("任务的状态有什么？\n对于 CPU 来讲，程序的执行主要依赖于内置存储：寄存器和内存（RAM），因此这两种硬件构成执行体的上下文。")]),v._v(" "),e("p",[v._v("对于寄存器来讲，其是CPU内部的原件，读写速度非常快，但是数量有限且存储内容有限。CPU 从软件 A 切换到软件 B 时，需要先将 A 用到的寄存器先保存起来以便后续恢复（保存到其他地方），然后将寄存器的值恢复到软件 B 上一次执行时的值，然后将执行权交给 B。")]),v._v(" "),e("p",[v._v("对于内存来讲（内存一般采用半导体存储单元，包括RAM-随机存储器、ROM-只读存储器、CACHE-高速缓存），在实模式和保护模式下内存访问机制是不同的。实模式下，多个执行体在同一个内存地址空间，相互之间没有干扰。在保护模式下，不同执行体可以有不同的内存地址空间，主要通过地址映射表来体现（而地址映射表也是通过寄存器来体现的）。")]),v._v(" "),e("p",[v._v("因此，总结而言，执行体的上下文就是一堆寄存器的值，要切换执行体，就是保存和恢复一堆寄存器的值。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("执行体")]),v._v(" "),e("th",[v._v("地址空间")]),v._v(" "),e("th",[v._v("调度方")]),v._v(" "),e("th",[v._v("时间片调度")]),v._v(" "),e("th",[v._v("主动调度")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("进程")]),v._v(" "),e("td",[v._v("不同进程有不同地址空间")]),v._v(" "),e("td",[v._v("操作系统内核")]),v._v(" "),e("td",[v._v("基于时钟中断")]),v._v(" "),e("td",[v._v("系统调用(syscall)")])]),v._v(" "),e("tr",[e("td",[v._v("线程")]),v._v(" "),e("td",[v._v("不同线程共享地址空间")]),v._v(" "),e("td",[v._v("操作系统内核")]),v._v(" "),e("td",[v._v("基于时钟中断")]),v._v(" "),e("td",[v._v("系统调用(syscall)")])]),v._v(" "),e("tr",[e("td",[v._v("协程")]),v._v(" "),e("td",[v._v("不同协程共享地址空间")]),v._v(" "),e("td",[v._v("用户态")]),v._v(" "),e("td",[v._v("通常不支持")]),v._v(" "),e("td",[v._v("包装系统调用")])])])]),v._v(" "),e("p",[v._v("通常，我们会认为进程是操作系统的隔离单位（安全角度），不同进程之间基于最低的授权原则进行通信。")]),v._v(" "),e("p",[v._v("如果从进程是 OS 最基本的隔离单元来看，unix/linux 体系的 fork 是一种过度设计的体现。因为 fork 会先 clone然后再分支，父子进程各干各的，但是子进程会在 clone的时候包含父进程的上下文。window的设计会更清晰，哪些文件句柄在子进程中会被用到，会被一一确定。fork的这种设计当时还没有线程的概念，因此进程实际承担了一部分来自线程的需求（我需要父进程的环境）。后来因为操作系统发现同一个软件内部还是会出现多任务的需求，这些任务处在相同的地址空间，彼此之间相互信任，因此线程的出现就是显然而然的。")]),v._v(" "),e("p",[v._v("协程通常不是操作系统提供的，因此也被称为用户态线程（轻量级线程）。")]),v._v(" "),e("p",[v._v("为什么会出现协程呢？看起来和线程需求一样，功能却弱很多？")]),v._v(" "),e("p",[v._v("这是因为高性能的网络服务器的需要。对于网络服务器来讲，大量来自客户端的请求包和服务器的返回包，都是网络 I/O；在响应请求过程中，也需要访问存储，这也涉及本地或网络 I/O。也就是说，服务器充斥着大量的并行 I/O 请求。")]),v._v(" "),e("p",[v._v("那么对于 OS 提供的标准网络 I/O 的成本有哪些？")]),v._v(" "),e("ul",[e("li",[v._v("系统调用机制产生的开销")]),v._v(" "),e("li",[v._v("数据多次拷贝的开销（数据总是先写到 OS 缓存，然后在到内存）")]),v._v(" "),e("li",[v._v("没有数据而阻塞，产生调度重新获得执行权，产生的时间成本")]),v._v(" "),e("li",[v._v("线程的空间成本和时间成本（标准 I/O 请求都是同步调用，要想 I/O 请求并行智能使用更多线程）")])]),v._v(" "),e("p",[v._v("对于第一点，开销并不太大。因为系统调用和普通的函数调用成本相当（不考虑调度行为）。系统调用多做了一点点事，比如查询了中断向量表、改变 CPU 的执行权限（从用户态到内核态再回到用户态）。")]),v._v(" "),e("p",[v._v("对于 OS 内核的主线程来讲，内核是一个独立的进程；从系统调用角度来看，OS 内核更像是多线程的程序，然后每个系统调用时来自某个线程的函数调用。")]),v._v(" "),e("p",[v._v("为了改变网络服务器的吞吐能力，主流做法是 linux 的 epoll 或者 windows 的 IOCP 机制，两者机制类似。在需要 I/O 时登记一个 I/O 请求，然后统一在某个线程查询谁的 I/O 先完成，先完成的就让它处理。")]),v._v(" "),e("p",[v._v("对于系统调用次数的角度， epoll 或 IOCP 都是产生了更多次数的系统调用。内存拷贝没有减少，真正有意义的是减少了线程的数量。如果都是同步 IO，每个并行IO都需要一个线程，而 epoll 让 io 等待都发生在相同的地方，也就是多路 IO 复用。")]),v._v(" "),e("p",[v._v("既不希望用太多的线程，网络服务器也不希望用标准的同步 I/O 来写程序。因此 异步 I/O 网络库 libevent 对于 epoll 和 IOCP 这些包装了一套跨平台的异步 I/O 编程模型。")]),v._v(" "),e("p",[v._v("但是异步 I/O 的代码组织逻辑不是正常的顺序线性思维。它让代码组织更加碎片化。我们减少线程数量的原因在于：")]),v._v(" "),e("ol",[e("li",[v._v("时间成本：\n"),e("ul",[e("li",[v._v("执行体切换本身的开销，主要是寄存器保存和恢复的成本，可优化的地步有限")]),v._v(" "),e("li",[v._v("执行体的调度开销，主要是如何在大量已经准备好的执行体中选出谁获得 CPU 的执行权")]),v._v(" "),e("li",[v._v("执行体之间的同步与互斥成本")])])]),v._v(" "),e("li",[v._v("空间成本：\n"),e("ul",[e("li",[v._v("执行体的执行状态")]),v._v(" "),e("li",[v._v("TLS（线程局部存储）")]),v._v(" "),e("li",[v._v("执行体的堆栈\n在 Linux下面，默认线程的空间是 几 MB，其中最大的成本是堆栈（堆栈大小可以设置，但是出于线程执行安全考虑，不宜设置太小）。\n如果我们有 1000 个线程，那么就已经达到 GB 级别了，消耗太快。而调度开销和同步、互斥成本也是不可忽略的（达到一定的次数量级）。")])])])]),v._v(" "),e("p",[v._v("对于网络服务器中，系统有大量的 IO 请求，大部分的 IO 请求正在处理中而没有命中，因此产生调度。并且网络服务器的存储也是个共享状态，必然伴随着大量的同步与互斥操作。")]),v._v(" "),e("p",[v._v("因此，协程的目的就是：")]),v._v(" "),e("ul",[e("li",[v._v("回归到以前同步 IO 的代码组织形式")]),v._v(" "),e("li",[v._v("降低执行体的空间成本和时间成本")])]),v._v(" "),e("p",[v._v("目前，大部分市场上的协程库都是只实现了部分功能。比如只有协程的创建和执行体的切换，缺失了：")]),v._v(" "),e("ul",[e("li",[v._v("协程的调度")]),v._v(" "),e("li",[v._v("协程的同步、互斥与通信")]),v._v(" "),e("li",[v._v("协程的系统调用包装，尤其是网络 IO 请求的包装")]),v._v(" "),e("li",[v._v("等等其他服务端操作系统需要的东西都要包装一遍")])]),v._v(" "),e("p",[v._v("另外，协程库的堆栈功能也是难题。太小不够用，太大空间成本过高，影响能够处理的网络请求并发数。因此理想情况下，堆栈大小能够自动适应需求最好。")]),v._v(" "),e("p",[v._v("因此一个完备的协程库可以理解为用户态的操作系统，协程就是用户态操作系统里面的“进程”。")]),v._v(" "),e("p",[v._v("目前 golang 和 Erlang 提供了完备的协程库。Erlang 基于虚拟机实现了协程库。Go 里面的 goroutine有一些重要设计：")]),v._v(" "),e("ol",[e("li",[v._v("堆栈开始很小（4K），可以按需自动增长")]),v._v(" "),e("li",[v._v("去掉 TLS 特性支持，精简执行体")]),v._v(" "),e("li",[v._v("提供了同步、互斥和常见通讯手段，比如 channel")]),v._v(" "),e("li",[v._v("提供几乎所有重要系统调用的包装（尤其是IO）")])]),v._v(" "),e("p",[v._v("协程在单位时间上去掉了从用户态到内核态再回到用户态的成本。（次数一多积累也很惊人）。")]),v._v(" "),e("p",[v._v("对于多任务的需求，出现了三套执行体：进程、线程和协程，以及各种执行体之间的通讯机制。一些正在消亡，新的也在出现。在操作系统内核之中的精妙设计中，也会出现决策上的失误，产生了后遗症。")]),v._v(" "),e("p",[v._v("OS 内核是庞大而复杂的基础软件。不像计算机基础体系结构简洁优雅。 对于 CPU 来讲，统一、接口一致的输入输出设备；对于 OS 来讲，需要依据每种设备的需求特性，抽象出对应的用户友好的使用接口。这种任务繁重并且需要极强的预见性。")]),v._v(" "),e("p",[v._v("经典的应对大量网络 io 的方式：")]),v._v(" "),e("ul",[e("li",[v._v("经典的线程池+异步 IO")]),v._v(" "),e("li",[v._v("基于协程的同步IO，原理同上。")])]),v._v(" "),e("p",[v._v("协程数量上只受制于内存（没有系统调用），线程切换的保存是保存在内存里面。")])])}),[],!1,null,null,null);_.default=r.exports}}]);