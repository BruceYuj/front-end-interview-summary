基础的 bfs，每次沿着分支扩展都记为 1 步，通过逐层搜索，解决了从**初始状态**到每个状态的最小步数问题。等价于在一张边权为 1 的图上执行广度优先遍历，求出每个点相对于起点的最短距离。对于最短路的一般性问题，我们可以通过 dijkstra 或者 bellman-ford 算法来做。

那么为什么这类特定的最短路问题可以使用 bfs 来解决呢？

因为 dijkstra 算法本质是贪心，第一次出堆的点就表示该点大热最短路已经求好了。而对于边权为 1 的点，每次向外扩一层，队列中的队列天然满足两段性和单调性。因此就不需要维护优先队列了，直接使用队列即可。

## bfs
广度优先搜索，很擅长解决 “走地图” 类问题 - 给定矩形地图，控制一个物体在地图中行走，求最短步数。

其通用的状态提取如下：
- 地图的整体形态固定不变，只有少数个体或特征会随着每一步操作发生改变。将变化的部分提取为状态。
- 比如最基础的走地图，只有坐标会不断变化，因此可以将坐标提取出来作为状态。

广度优先搜索是逐层遍历搜索树的算法，所有状态按照入队的先后顺序具有层次单调性。如果每一次扩展恰好对应一步，那么当一个状态第一次被访问时（入队），就得到了从起始状态到达
该状态的最小步数。

[bloxorz](https://www.acwing.com/problem/content/174/)

状态提取：地图整体不变，变化的部分是长方体的位置和放置形态。因此，我们可以通过一个 `(x, y, lie)` 来表示状态。由于长方体是 1*2 的，因此会有两个坐标。如果我们直接用 `(x1, y1, x2, y2)` 来表示状态也可。

状态表示为 `(x1, y1, x2, y2)`, 会有 三种情况：
- `x1= x2, y1 = y2`
- `x2 = x1 + 1, y1 = y2`
- `x1 = x2, y2 = y1 + 1`
  
这样表示状态，对于状态转移非常不方便。比如对于 3 种状态，我们需要分别扩出 4 种状态进行分类讨论。太过于麻烦。

因此，直接通过 `(x, y, lie)` 来表示状态更好。
- lie = 0, 表示立着
- lie = 1，表示横向躺着，(x, y) 表示左边的坐标
- lie = 2，表示竖向躺着，(x, y) 表示上边的坐标



## 多起点 bfs

> 多起点 bfs 求最短路 - 初始状态有多个起点的 bfs，其等价于建立一个虚拟节点 0，0 向所有起点连一条边权为 0 的边，求该点 0 到其他点的最短距离。

[矩阵距离](https://www.acwing.com/problem/content/175/)

给定一个 0/1 矩阵，求所有点到值为 1 的点中的最短距离。朴素做法-对所有点进行 bfs，遍历到第一个值为 1 的点就得到答案。时间复杂度为 `$O(n^2m^2)$`。

这里我们可以反过来思考，建立一个虚拟源点，该点向所有值为 1 的点建立一条长度为 0 的边，求虚拟远点到所有点的最短路。由于该图的边权都为 1（虚拟原点不算），因此可以使用 bfs 来做。而虚拟原点也不需要实际建出来，因为边权为 0，可以直接加入到队列中。



扩展：如果边权不为 1，如何处理？

同样建立一个虚拟原点，然后通过 堆优化的 dijkstra 算法来做。

## 双端队列
对于 **边权为 0 或 1** 的图来讲，我们可以通过双端队列来解决最短路问题。其过程如下：
- 新扩展的点如果边权为 0，队头插入
- 新扩展的点如果边权为 1，队尾插入

整个队列仍然满足两段性和单调性。时间复杂度仍然为 `$O(RC)`

[175. 电路维修](https://www.acwing.com/problem/content/description/177/)

主要思路是：求起点到终点的最短路，对角线走法，转动的代价为边权，因此边权为 0 或 1。


## 优先队列 bfs
在最短路题目中，如果每条边的边权不同时，我们通常有两种方案：
1. spfa 算法 - 对搜索树重复遍历与更新，直到收敛到最优解
2. 基于优先队列的 dijkstra 算法 - 每次取出当前代价最小的状态进行扩展（证明-反证法）

[176. 装满的油箱](https://www.acwing.com/problem/content/178/)

如何确定状态？
我们不能直接以城市编号作为状态，因为代价不是城市间的距离。而是在该距离消耗的油所对应的钱。如果状态只有城市一个维度，没有办法进行状态转移。

> 当图中一个点记录多个信息时，通常的做法是 **拆点**，也就是每个维度都拆成一个点，如下。
我们来看会变化的维度：
1. 不同的城市肯定会成为一个维度
2. 到达每个城市时，油箱的油也是变化点，需要作为一个维度

因此，我们 `(city, fuel)` 组成状态。

> 这里需要注意的是，在图论中，我们会提前给出所有的节点和边。而在某些题目中，节点需要我们自己抽象出来，比如本题，每个状态都是一个节点。边由具体的状态扩展。

开始状态 `(start, 0)`, 结束状态 `(end, 0)`

