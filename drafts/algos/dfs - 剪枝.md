
我们知道 dfs 往往代表着暴力解法，而其往往有三种最简单的形式：
- 指数型： 子集和 问题
- 排列型：全排列问题
- 组合型： N 皇后问题

这三种是可以常见的搜索中的 NPC 问题。

由于属于暴力写法，其效率也就是需要考虑的问题。而剪枝是常用的提高时间效率的手段，其分类通常有 5 种：

1. 优化搜索顺序：搜索树的各个层次、分支之间的顺序不是固定的。不同的搜索顺序会产生不同的搜索树形态，其搜索树的形态也不一样。
    - 比如数独问题：优先搜索 “能填合法数字” 最少的位置。
2. 排除等效冗余： 在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，我们就可以只对其中一条分支进行搜索。
    - 比如 sticks 问题
3. 可行性剪枝：如果在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法达到递归边界，就直接进行回溯
4. 最优化剪枝： 在最优化问题当中，如果当前话费的代价已经操作当前的最优解，就直接回溯
5. 记忆化：可以记录每个状态的搜索结果，避免重复遍历。


[生日蛋糕](https://www.acwing.com/problem/content/170/)

搜索框架：从下往上搜索，枚举每层的半径和高度作为分支。

搜索的状态有：
- 当前搜索的层次 - dep
- 当前外表面面积 - s
- 当前体积 - v
- 第 dep + 1 层的高度和半径 - 使用数组 h 和 r 进行保存。

`S = 最下层的底面积 + 所有层次的侧面积`，因此我们可以在第 m 层直接累加底面积，这样在其他层搜索时候直接算侧面积即可。

剪枝：
1. 上下界剪枝
在第 dep 层是，`R \in [dep, min(\sqrt(N-v), r[dep+1]-1)]`
`H \in [dep, min((N-v)/R^2, h[dep+1]-1]`。右边界通过圆柱体公式求得。
另外我们可以进一步缩小右边界范围。

计算`[1, dep-1]` 的最小体积分别是 `1, 2^3, 3^3, ...`.。假设最小体积和为 minV.
`R \in [dep, min(\sqrt(N-v-minV), r[dep+1]-1)]`
`H \in [dep, min((N-v-minV)/R^2, h[dep+1]-1]`。

2. 优化搜索顺序 - 从大到小枚举
3. 可行性剪枝：
   - 可以提前预处理出从上往下的前 i 层的最小体积和侧面积。显然当第 1～i 层，半径和高度分别取 1～i 时，有最小的体积。如果当前体积加上最小体积大于 N， 可以剪枝。（和上面的上下界剪枝中被用到）
4. 最优化剪枝
   - 如果当前表面积 s 加上  `[1， dep-1]` 层的最小侧面积已经大于当前解，则剪枝。
   -  利用体积和表面积之间的关系进行放缩来。剩下的 depth-1 层的最小比啊面积一定大于等于 `2(n-v)/r[dep]` 

> 搜索算法的状态可以看成一个多元组，其中每一元都是问题状态空间的一个维度。比如层数 dep，表面积 s，体积 v等。其中每一项发生变化，都会导致搜索树中的状态转移。这些维度通常也会在题目描述中体现。而搜索过程中的剪枝，就是对每个维度的边界条件进行放缩推导，地出一个相应的不等式，来减少搜索树的分支扩张。
> 除了当前花费的代价，还可以对未来至少需要花费的代价进行预算，来更加接近每个维度的上下界。


