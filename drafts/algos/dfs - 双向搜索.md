
1. 双向搜索可以避免在 **深层子树** 上面浪费时间。因为通常来讲，子树增加一层，状态是 **指数级** 增加。从初态和终态出发各自搜索一半状态，产生两棵深度减半的搜索树，在中间交汇、组合成最终的答案。
2. 双向搜索用于 - 问题知道明确的 “初态” 和 “终态”， 并且从初态正向搜索或者终态逆向搜索都能够覆盖整个状态空间。


[送礼物](https://www.acwing.com/problem/content/173/)
> 题目是 “子集和” 的扩展。根据数据范围来决定是用 “背包” 还是用 “搜索” 解决。

1. 背包的时间复杂度是 $O(nm)$, 超时。
2. 普通搜索时间 $O(2^n)$, 超时。运用 **可行性剪枝** 仍然会超时。

双向搜索解决：
1. 从前一部分（通常是前一半）中选择地出一堆重量值。
    - 排序：可以二分
    - 去重：等效冗余
    - 大于 w 的去除：可行性
2. 从后半部分进行搜索，得到最终的状态 s，在前面的重量值中进行二分搜索 - 最接近的 `s+x<= w`。

提高搜索效率：
- 调整搜索顺序 - 排序重量，从大到小进行折半、搜索
- 选取适当的 “折中点”

> 另外，我们可以将 dfs 改成迭代的模式。不过由于 dfs 的嵌套深度不深，所以一半不会栈溢出。