
## 线性 dp


## 状压 dp


### 题目
1. [acwing 91. 最短Hamilton路径](https://www.acwing.com/problem/content/description/93/)

题目分析：

本题给定一个 $n$ 个点的带权无向图，求从点 $0$ 到 $n-1$ 的最短 Hamilton 路径。数据范围 $n \in [1, 20]$。

朴素做法就是枚举 n 个点的全排列（方案），然和计算每个方案中的最小值（时间复杂度 $O(n*n!)$）。

看到最短路，会想到图论和最优化问题。由于本题要求 Hamilton 路径，基础图论算法当中并没有直接求解的算法，因此我们往贪心和动态规划考虑。由于数据范围很小，因此我们可以用状压来表示目前经过的点的方案。

比如第 0 位为 1，表示 点 0 已经被经过，因此我们只需要 $[0, 2^{20})$ 来表示所有经过的方案。

我们设定 $f[i][j]$ 表示当前已经经过点的状态为 $i$ 且当前的点为 $j$。根据该设定，我们可以得出：`i>>j&1 == 1`。最后的答案就是 $s[1<<n-1][n-1]$。

要求$f[i][j]$，我们可以枚举所有 $i$ 中已经经过的点，设为 $k$: $f[i][j]  = min(f[i \oplus 1 << j, k])$。

```python
if __name__ == "__main__":
    n = int(input())
    g = [[] for i in range(n)]
    
    for i in range(n):
        g[i] = list(map(int, input().split()))
        
    f = [[float("inf")] * n for i in range(1<<n)]
    
    f[1][0] = 0
    
    for i in range(1, 1<<n):
        for j in range(n):
            if i >> j & 1:
                for k in range(n):
                    if (i ^ 1<<j) >> k & 1:
                        f[i][j] = min(f[i][j], f[i^1<<j][k]+g[k][j])
    
    # print(f)
    print(f[(1<<n)-1][n-1])
```

枚举状态的顺序很重要：因为动态规划需要新状态依赖的旧状态被提前计算出来。我们看看本题的状态设计：
- 新状态为 $i$, 旧状态为 `i^1<<j`，其是小于 $i$ 的，因此所有旧状态一定已经被计算出来了
- 初始化，我们初始化所有的状态的最小值为正无穷。而只有起点 0 的状态的最短路为 0，也就是 $f[1][0] = 1$。


时间复杂度为 $O(2^n*n^2)$ 是足够的，虽然中间会经过很多无效状态，但是足够了。

