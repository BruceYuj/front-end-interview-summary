

树形 dp 是一类在树上进行动态规划的题目。

其题目描述一般如下：

给定一棵有 N 个节点的树（通常形容为没有根，有 N-1 条无向边），选择任意一个节点作为根节点，从而定义出每个节点的深度和每棵子树的根。

在树上进行 dp，一般 **以节点从深到浅（子树从小到大）的顺序作为 dp 的阶段**，dp 的状态表示中，第一维通常是节点编号（代表以该节点为根的子树）。通常我们用递归的方式实现树形动态规划。对于每个子节点 x，先递归在它的子节点上进行 dp，在回溯时，从子节点向节点 x 进行状态转移。



1. [acwing 285. 没有上司的舞会](https://www.acwing.com/problem/content/287/)

根据题目分析：

$f(i, 0)$ 表示以 i 为根节点的子树且不选择 i 的最大快乐值，$f(i, 1)$ 表示以 i 为根节点的子树且选择 i 的最大快乐值。

那么答案就是 $max(f(root, 0), f(root, 1))$

$f(i, 0) = \sum max(f(son, 1), f(son, 0))$

$f(i, 1) = \sum f(son, 0) + value(i)$


最小子问题，也就是叶子节点代表的问题: $f(leap, 0) = 0, f(leap, 1) = value(leap)$



2. [acwing 286. 选课](https://www.acwing.com/problem/content/288/)
本题属于经典的 **有树形依赖的背包问题**。


- N 门课形成一棵森林
- 如果想要修子节点的课，必须得先修完从根节点到子节点上的所有父节点的棵
- 总共可以修 M 门课

如果枚举森林中的每棵树，代码稍微复杂。可以通过抽象出一个虚拟节点来表示所有树的根，设编号为 0，学分为 0。这样题目就变成了修 M+1 门课的最多学分了。

$f(i, j)$ 表示修以 i 为节点的子树，共 j 门课的最多学分。

则答案为 $f(0, M+1)$

状态转移方程为 $f(i, j) = max(\sum_{\sum x = j-1} f(son[i], x)) + score(i)$, 也就变成了分组背包问题。

递归出口： $f(leap, 0) = 0$， 其余的初始化为 -INF。（由于学分肯定是正的，也就可以全部初始化为 0）.

为什么是分组背包问题？

$f(i, j)$ 一定要选 i 这门课，剩下 j - 1 门课，在 i 的子节点上选择。也就是每个子节点选择 $[0, j-1]$ 门课的，且所有子节点上选的课和为 j-1。

也就是将所有子节点当成分组的背包，然后背包中的元素分别是 $0, ...., j-1$ 门课即可。

为什么不可以是 01 背包？因为是有依赖的，一定要选父节点。所以没办法 01 背包。


