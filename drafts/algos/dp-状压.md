

在常见的**线性 dp** 当中，整个过程随着阶段在每个状态维度上不断扩展。比如常见的背包dp - $f(i, j)$ 随着 i 阶段在 j 的维度上不断扩展，直到求出最终答案。

在任何时刻，已经求出的状态和未求出的状态在各维度上的分界点形成了 dp 扩展的轮廓。

在 dp 中存在一类问题，需要在状态中记录一个**集合**，保存轮廓的详细信息，便于状态转移。如果该集合大小不超过 N，且每个元素都是小于 k 的自然数，那么我们可以通过一个 N 位的 K 进制数来表示该集合，并且作为状态的一维出现。这种将**集合转换为整数记录在 dp 状态中**的一类算法被称为状压dp。


[acwing 291. 蒙德里安的梦想](https://www.acwing.com/problem/content/description/293/)

本题将 $n*m$ 的棋盘分割成 1*2 的长方形。长方形有两种形式：横着放和竖着放。

朴素做法可以通过枚举每个点的每个选择，来判断方案是否合理，时间复杂度达到 $2^{nm}$ ，超时。

仔细观察会发现，在枚举每一行的时候，第 i 行会受到第 i-1 行的竖着放着的影响。而第 i-1 行横着放的对第 i 行没有影响。

因此，我们可以根据第 i-1 行竖着放的来快速得到第 i 行的摆放情况。由于 n 和 m 很小。

那么，我们可以通过 $[0, 2^m-1]$ 来表示该行每个位置是竖着放还是横着放。

$f(i, state)$ 就是状态。 $f(0, 0) = 1$, $f(n, 0)$ 就是答案。

那么状态转移方程是什么？

$f(i, state) += f(i, k)$ 

- k 和 state 的任何一位不能同时为 1，也就是按位与为 0
- state的横着的位置，每一段必须是偶数个，因为长为 2。所以 k 和 state 按位或之后的连续 0 都是偶数个。

在这里，我们可以通过预处理优化第二步，求出合法连续 0 为偶数个的所有可能状态。


[acwing 292. 炮兵阵地](https://www.acwing.com/problem/content/description/294/)

朴素做法枚举每个点，然后分别判断是否放还是不放，时间复杂度为 $O(2^{nm})$

仔细观察，我们发现第 i 行的点会受到第 i-1 行和第 i-2 行影响。









































































































































































































































































































































































































