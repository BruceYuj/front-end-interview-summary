
线性 dp：一般是从**初始状态** 开始，沿着阶段的扩张向某个方向递推，直至计算出目标状态。

而区间 dp 是一类特殊的线性 dp，其一般以 **区间长度** 作为阶段，使用两个坐标（左右端点）来描述每个维度。

区间 dp 的初始状态一般是长度为 1 的元区间。

1. [acwing 282. 石子合并](https://www.acwing.com/problem/content/284/)

假设 $f(l, r)$ 表示区间为 $[l, r]$ 合并的最小代价。

那么我们可以根据区间中的切割位置进行划分，将大区间分成两个小区间
- 在位置 l 处切割： $f(l, l) + f(l+1, r) + s[r] - s[l-1]$
- 在位置 l+1处切割：$f(l, l+1) + f(l+2, r) + s[r] - s[l-1]$
- ...
- 在 r-1处切割:$f(l, r-1) + f(r, r) + s[r] - s[l-1]$

求 min 即可。
$f(l, l) = 0$，其余为 正无穷。


2. [acwing 283. 多边形](https://www.acwing.com/problem/content/285/)

题目分析：
1. 不断消掉顶点，求最后的最大值
2. 顶点操作只有乘法和加法；由于顶点数值有正有负。

- 对于加法而言：正数相加一定大于负数相加
- 对于乘法而言：正数相乘不一定大于负数相乘

因此两个顶点操作后的最大值只能在：
- 两个顶点的最大值相乘或相加
- 两个顶点的最小值相乘(负负得正)

操作后的最小值：
- 两个最小值相加或相乘
- 一个最大值和最小值相乘


因此，如果只用 $f(l, r)$ 两维信息来保存 dp的话，不符合 **最优子结构** 性质，因此我们需要多添加一维来同时保存最大值和最小值。

$f(i, j, 0)$ 表示最大值，$f(i, j, 1)$ 表示最小值。

状态转移方程，枚举最后一刀的划分方式，也就是枚举将 $[l, r]$ 划分成两个区间的所有划分方式：

$f(i, j, 0) = max(f(i, k, 0) \  op \ f(k+1, j, 0), f(i, k,1) \ op \  f(k+1, j, 1))$

$f(i, j, 1) = min(f(i, k, 1) \ op \ f(k+1, j, 1), f(i, k, 0) \ op \ f(k+1, j, 1), f(i, k, 1) \ op \ f(k+1, j, 0))$

初始化： $f(i, i, 0) = f(i, i, 1) = a[i]$
其他 $f(i, j, 0)$ 初始化为正无穷；$f(i,j,1)$ 初始化为负无穷。


求： $f(1, n, 0)$


由于题目本身是一个环：
而上面的状态转移的是：从编号 1 到 编号 N 合并和的最大值。而如果是环的话,总共有 N 种遍历可能：
1. $1, ... , N$
2. $2, ... , N, 1$
3. ...
4. $N, 1, ..., N-1$

如果枚举所有的可能的话：时间复杂度为 $O(N^4)$， 数量级在 $6*10^6$。但是通常对于这类环的问题，我们通常有一个技巧将复杂度降低一个循环：复制同样的数组接到原数组的后面，对新数组进行一次 dp 即可。

$1, ... , N , 1, ... , N$ ，也就是 $a[i] = a[i+n], i \in [1, n]$

那么 $max(f[i][i+n-1][1]), i \in [1, n]$ 即为所求。

这样时间复杂度降低到 $O(N^3)$


1. [acwing 284. 金字塔](https://www.acwing.com/problem/content/286/)


dfs 序与欧拉序

dfs 序：指一棵树被 dfs 时所经过节点的顺序。

比如：
```
   A
  / \
 B   c
  \
   D
```
上面的 dfs 顺序就是： `ABDC`


欧拉序：从根节点出发，按照 dfs 的顺序遍历回到根节点的所经过的所有点的顺序

https://www.cnblogs.com/stxy-ferryman/p/7741970.html

https://blog.csdn.net/qq_39670434/article/details/78425125

通常来讲，欧拉序有两种表达形式
1. `ABDBACA`
2. `ABDDBCCA`


dfs 序的好处是什么？

其可以将一棵树区间化。对于任意一种 dfs 序的表达方式，任意一棵子树一定只对应 dfs 序中的连续一段。

这往往可以和区间相关的算法结合起来，比如区间 dp，RMQ 等等。

欧拉序 1 的应用：
1. 求 LCA
2. 求子树的权值之和


本题题意用的是 **欧拉序 1**：

设有 $n$ 个点，那么共有 $n-1$ 条边，那么遍历得到的 dfs 序共有 $2(n-1) + 1 = 2n - 1$ 个点。

对于任意一棵子树形成的序列而言，其在整个序列中一定是连续的一段，设为 $s[l, r]$ ，得到 $s[l] = s[r]$

对于本题来讲，求 $[0, n-1]$ 这个序列构成的多叉树的种类。

这里，我们假设 $f[l, r]$ 表示 $[l, r]$ 的序列区间可以构成的多叉树的种类。

那么状态转移方程如何得到呢？

我们枚举 $[l, r]$ 所对应子树的最后一棵子树。

也就是枚举 $[l, r]$ 上的划分方式：
$f[l, k] * f[k+1, r-1]$ 

因此， $f(l,r) = sum(f(l, k) * f(k+1, r-1))$

初始化：$f(i, i) = 1$, 其余默认为 0

这里，我们可以采取一些剪枝策略：
1. 按照题意，任何子树得到的 dfs 序列的大小一定是奇数，因此，我们遍历长度时候可以是奇数遍历。









