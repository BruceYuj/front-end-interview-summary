
## 定义

## 题目

1. [acwing 271. 杨老师的照相排列](https://www.acwing.com/problem/content/description/273/)

核心概念：
> 从高到低依次安排每个同学位置。假设当前安排第 $i, i \in [ 1, n]$ 个学生，那么前 $i-1$ 个学生一定占据每一排最靠左的连续若干个位置，并且从后往前每排人数单调递减。否则一定不满足“每一排从左到右身高递减，从后往前递减”。

为什么上面的成立？
1. 因为我们是从高到低排的，那么前 $i-1$ 个学生身高一定大于第 $i$ 个学生。那么这些最高的 $i-1$ 个学生一定在每一排最靠左的位置，否则与定义不符合
2. 为什么从后往前每排人数单调递减？反证法即可。假设第 $x$ 排人数大于第 $x-1$ 排，由于从高到低安排，所以剩下的 $n-i$ 个身高一定小于所有已经安排的身高，那么剩下的任意身高都不能放在第 $x-1$ 排，也就不满足定义 $N_1>N_2>...>N_k$,得证。


根据上面的性质我们可以假设：$f[a][b][c][d][e]$ 表示从后往前每排人数为 $a,b,c,d,e$ 的所有方案的集合，其中 $a \geq b \geq c \geq d \geq e$。


状态计算 - 对应当前集合的划分，本题按照**最后一个同学被安排在哪一排**作为划分依据，可以将 $f[a][b][c][d][e]$ 划分成**不重不漏**的 5 个子集：
- 当 $a > 0, a > b$ 时，最后一个同学可以被安排在第一排，方案数是 $f[a-1][b][c][d][e]$
- 当 $b > 0, b > c$ 时，最后一个同学可以被安排在第二排，方案数是 $f[a][b-1][c][d][e]$
- 当 $c > 0, c > d$ 时，最后一个同学可以被安排在第三排，方案数是 $f[a][b][c-1][d][e]$
- 当 $d > 0, d > e$ 时，最后一个同学可以被安排在第四排，方案数是 $f[a][b][c][d-1][e]$
- 当 $e > 0$ 时，最后一个同学可以被安排在第五排，方案数是 $f[a][b][c][d][e-1]$


时间复杂度： $O(k(\frac{N}{k})^k)$

> 思考：这里我们需要思考的是，设计 dp 的状态转移方程时，是否一定要从 “如何计算出当前状态” 来求出呢？答案是不一定，我们也可以从“一个已知状态应该更新哪些后续阶段的未知状态”。对于本题来讲，两种方式都可，对于某些题目来讲，第二种方式更加自然、方便。

2. [acwing 272. 最长公共上升子序列](https://www.acwing.com/problem/content/description/274/)

本题是 LIS 和 LCS 的结合。

我们先来看 LIS 问题：

其状态定义是 $f[i]$, 表示以 i 为结尾的最长上升子序列的长度。我们可以在 $O(n^2)$ 的时间复杂度得到答案（另外一种解法是贪心+二分）

再来看 LCS 问题：

状态定义是 $f[i][j]$, 表示以 $A[0,i], B[0, j]$ 区间的最长公共子序列。

那么 LCIS 问题就是两者的结合。
我们可以这么定义状态：$f[i][j]$ 表示 $A[0, i], B[0, j]$ 范围内并且以 $B[j]$ 结尾的最长公共上升子序列的长度。

下面就变成了集合划分：
1. 如果 $A[i] = B[j]$, 那么 $f[i][j] = max_{k=1}^{k=j-1}(f[i-1][k]) + 1, B[k] < A[i] = B[j]$
2. 如果 $A[i] \neq B[j]$, 那么 $f[i][j] = f[i-1][j]$

朴素做法三重循环即可。
```python
if __name__ == "__main__":
    n = int(input())
    N = n+1
    
    a = [0] * N
    b = [0] * N
    
    f = [[0] * N for i in range(N)]
    
    a[1:N] = map(int, input().split())
    b[1:N] = map(int, input().split())
    a[0] = b[0] = float("-inf")
    
    for i in range(1, N):
        for j in range(1, N):
            if a[i] == b[j]:
                for k in range(j):
                    if b[k] < a[i]:
                        f[i][j] = max(f[i][j], f[i-1][k]+1)
            
            else:
                f[i][j] = f[i-1][j]
    
    ans = 0
    
    for i in range(1, N):
        ans = max(ans, f[n][i])
    
    print(ans)
```

时间复杂度 $O(n^3)$

在转移过程中，我们可以将满足 $k \in [0, j), 且 B[k] < A[i]$ 的所有 k 构成一个集合，并且将这个集合称为 $f[i][j]$ 进行状态转移时的决策集合，记为 $s[i][j]$。

我们会发现在第二层循环 $j$ 从 1 到 m 是，第一层循环 i 是定值，这表示条件 $A[i]$ 在第二层循环时是固定的。那么当 j 增加 1 时，k 的取值范围从 $[0, j)$ 变成了 $[0, j+1)$ ，也就是说 j 会进入到决策集合当中，由于在第三层循环中求的时最大值，那么我们只需要比较 $[0, j)$ 中的最大值和当前 j 比较即可。也就是说，我们用一个变量存储 $[0,j)$ 的最大值，这样我们就能在 $O(1)$ 求出第三层循环的值了。这样，避免重复扫描。

```python


if __name__ == "__main__":
    n = int(input())
    N = n+1
    
    a = [0] * N
    b = [0] * N
    
    f = [[0] * N for i in range(N)]
    
    a[1:N] = map(int, input().split())
    b[1:N] = map(int, input().split())
    a[0] = b[0] = float("-inf")
    
    for i in range(1, N):
        val = f[i-1][0]
        for j in range(1, N):
            if a[i] == b[j]:
                f[i][j] = max(f[i][j], val+1)
            else:
                f[i][j] = f[i-1][j]
                
            if b[j] < a[i]: val = max(val, f[i-1][j])
            
    ans = 0
    
    for i in range(1, N):
        ans = max(ans, f[n][i])
    
    print(ans)
```