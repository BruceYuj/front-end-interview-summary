
## introduction
前缀和算是算法题目中和 **区间** 相关题目的特殊技巧之一。
其可以在 $O(1)$ 的范围内获取任意区间范围 (比如 $[l, r]$)  

这种技巧可以在更加优秀的时间复杂度情况下解决一堆问题。



我们来看下 **前缀和** 的技巧应用：


[1230. K 倍区间](https://www.acwing.com/problem/content/1232/)

题目问： 连续子序列和是 K 倍数的个数

转换成公式就是： $(sum[j] - sum[i-1]) \ mod \ k = 0$.

朴素做法是什么？
> 枚举 i 和 j，然后看 $[i, j]$ 是否满足要求。时间复杂度 $O(n^2)$，显然会超时。

那么我们是否由更加简单的做法呢？
这里会运用到一些数学上的技巧。我们可以将任意的区间和分成 $k$ 类，具体分类方式根据 $x \ mod \ k$ 来划分。

那么每一类中的任意两个元素都可以构成一个 K 倍区间。证明如下：
**假设是第 i 类元素中的两个元素，根据划分方式可以得到：**

$x = i + a * k$ 和 $y = i + b * k(y > x)$，那么 $y-x = (b-a)k$ ，证明完毕。

也就是一个组合数计算而已。

```python
from collections import defaultdict

if __name__ == "__main__":
    n, k = map(int, input().split())
    
    s = [0] * (n + 1)
    
    for i in range(1, n+1):
        s[i] = s[i-1] + int(input())
    
    d = defaultdict(int)
    
    d[0] = 1
    
    res = 0
    for i in range(1, n+1):
        t = s[i] % k
        res += d[t]
        
        d[t] += 1
    
    print(res)
```