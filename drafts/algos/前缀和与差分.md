
## 前缀和
前缀和算是算法题目中和 **区间** 相关题目的特殊技巧之一。
其可以在 $O(1)$ 的范围内获取任意区间范围 (比如 $[l, r]$)  的和，朴素做法是 $O(n)$ 复杂度。 

### 模板题目
https://www.acwing.com/problem/content/797/

假设原始数组为 a，长度为 n（下标从 1 开始计算）。则对应的前缀和数组 $s[i] = a[1] + a[2] + .... + a[i]$。
则 $[l, r]$ 的和为 $s[r] - s[l-1]$

> 下标从 1 开始计算是为了避免边界情况，比如我们想要求 $[1, r]$ 的和，从 0 开始计算的话会没法统一 $s[l-1] = s[-1]$,在程序上面非法。

```python
if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    s = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    for i in range(1, n+1):
        s[i] = s[i-1] + a[i]
        
    while m:
        
        l, r = map(int, input().split())
        
        print(s[r]-s[l-1])
        
        m -= 1
```

将数组扩展到二维矩阵，就得到了二维前缀和的技巧。其可以在 $O(1)$ 时间复杂度获得任意子矩阵的和。
为了简化边界情况，同样我们的下标从 1 开始计算。
$s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]$ 得到
https://www.acwing.com/problem/content/798/

```python
if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    s = [[0] * (m+1) for i in range(n+1)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]
    
    while q:
        x1, y1, x2, y2 = map(int, input().split())
        
        print(s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1])
        
        q -= 1
```


我们来看下 **前缀和** 的技巧应用：
[1230. K 倍区间](https://www.acwing.com/problem/content/1232/)

题目问： 连续子序列和是 K 倍数的个数

转换成公式就是： $(sum[j] - sum[i-1]) \ mod \ k = 0$.

朴素做法是什么？
> 枚举 i 和 j，然后看 $[i, j]$ 是否满足要求。时间复杂度 $O(n^2)$，显然会超时。

那么我们是否由更加简单的做法呢？
这里会运用到一些数学上的技巧。我们可以将任意的区间和分成 $k$ 类，具体分类方式根据 $x \ mod \ k$ 来划分。

那么每一类中的任意两个元素都可以构成一个 K 倍区间。证明如下：
**假设是第 i 类元素中的两个元素，根据划分方式可以得到：**

$x = i + a * k$ 和 $y = i + b * k(y > x)$，那么 $y-x = (b-a)k$ ，证明完毕。

也就是一个组合数计算而已。

```python
from collections import defaultdict

if __name__ == "__main__":
    n, k = map(int, input().split())
    
    s = [0] * (n + 1)
    
    for i in range(1, n+1):
        s[i] = s[i-1] + int(input())
    
    d = defaultdict(int)
    
    d[0] = 1
    
    res = 0
    for i in range(1, n+1):
        t = s[i] % k
        res += d[t]
        
        d[t] += 1
    
    print(res)
```



**衍生题目**：
https://www.acwing.com/problem/content/description/101/

思路：由于边界上的点不算，所以我们可以通过稍微偏移 R 矩阵来达到内部目的，也就变成了 R-1 的矩阵（包含边界）。
这样就变成了二维前缀和问题。


1. [leetcode 560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

经典的**前缀和+哈希表优化**的题目。

用数据结构来优化算法是常见的一种技巧。比如上面这一类题目就是经典的通过哈希表来优化前缀和的计算过程。


其他题目
1. [leetcode 525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)
2. [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

另外，我们也可以直接通过本题将题目扩展到求方案数。

哈希表优化: 比如两数之和

3. [leetcode 1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

题目表面来看是一道 **二维前缀和** 的问题。

题目要求我们枚举所有的子矩阵，那么该如何确定一个子矩阵呢？
1. 通过左上角和右下角可以唯一确定一个子矩阵
2. 通过上下左右四条边可以唯一确定一个子矩阵

先来分析第一个方法：
枚举所有的左上角和右下角的时间复杂度是 $O(n^2*m^2)$，而计算具体子矩阵的和可以通过二维前缀和优化到 $O(1)$, 因此总时间复杂度为 $O(n^2m^2)$, 对应的数据量是 $10^8$，具有超时的风险。

第二个方案的分析：
枚举 4 条边的复杂度是 $O(n^2m^2)$，但是通过哈希表可以加快第 4 条边的搜索。具体过程如下：
1. 枚举上下边界
2. 枚举右边界，来查看是否有合适的左边界。而这个具体的过程就是上题的过程。已知列的数组，求连续子数组的和是 target 的个数。而我们可以通过动态维护列的和来快速求出 target的个数。

3. [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

本题是经典的：一维数组求最大连续子数组和+加限制+扩展到二维

首先**一维最大连续子数组和**常用解法：
1. 动态规划：$f(i)$ 表示以 i 结尾的最长连续子数组和，时间复杂度为 $O(n)$
   - $f(i) = max(f(i-1)+a[i], a[i])$

2. 枚举+剪枝优化：如何求以 i 结尾的最长连续子数组和呢？我们知道，前缀和可以在 $O(1)$ 求出任意区间的和，$s[i] - s[x]$ 表示 $[x+1, i]$ 整个区间。$s[i]$ 是定值，要是 $s[i] - s[x]$ 最大，也就是要使 $s[x]$ 尽量最小，也就是我们要求在 $[0, i-1]$ 区间的 s 的最小值。朴素方式是枚举这个区间，时间复杂度是 $O(n)$，但是我们发现最小值可以由前一个阶段的最小值和当前的值比较求出，也就是将前面阶段的最小值通过一个变量保存。这样避免重复计算，时间复杂度降低到 $O(1)$。总的时间复杂度是 $O(n)$

**一维最大连续子数组和+上界**：
此时，上述动态规划的方式就无法解决了。因为在子问题阶段无法通过简单方式来定义**上界** 这个维度信息。

换句话说，如果我们以子数组的结尾作为阶段，没有办法通过已求的阶段解来求出当前阶段的解，也就是不满足最优子结构特性。

那么第二种方式呢？
我们期望找出最接近 k 的子数组大小，换句话说也就是 $s[i] - s[x]$ 要接近 k，也就是 $abs(s[i] - s[x] - k)$ ，因为 $s[i] - k$ 是定值，我们需要使上面的公式最小，也就是期望找到一个 $s[x]$ 最接近 $s[i] - k$。

如果本身数组元素没有负数的话，我们可以根据**前缀和**的非严格单调递增特性，进行二分查找在 $logn$ 时间求出最接近的值。

但是如果数组元素存在负数，那么前缀和本身就失去了单调特性，这样我们可以通过**有序集合**（具体原理可以用红黑树来做）来维护遍历过的位置，这样我们也可以在 $logn$ 时间内求出最接近的值，并且在 $logn$ 内维护有序集合。

扩展到二维该如何处理呢？

正如上一题所提到的一样，我们可以枚举上下界来解决问题。
当固定了上界后，下界可以以 +1 的递增方式枚举。这样，我们可以在 $O(n)$ 时间内快速求的上下界固定的每一列的和。也就是说，我们在上下界固定时，将问题转换成了**一维求最大接近 k 的子数组和**，而这个问题的解法如上是 $O(nlogn)$，因此总的时间复杂度变成了 $O(m^2*nlogn)$

如果向要在优化，就要比较 m，n 的大小来定具体固定上下还是左右的边界。

空间复杂度为 $O(max(m, n))$

有序集合：
- Java 中可以通过 TreeSet 解决
- c++ set 解决
- python3 sortedcontainers.SortedList


## 差分
> 差分也被称为前缀和的逆运算，通常也被分为 1 维 和 2 维

假设存在一个整数数组 a, 我们需要构造一个数组 b，使得：
$a_i = b_1 + b_2 + ... + b_i$。

这样的构造可以用来解决一类问题：
将对区间 $[l, r]$ 范围内都加上一个数的时间复杂度由 $O(n)$ 降低到 $O(1)$。

举例， a $[l, r]$ 范围都加上 C, 转换到 b 数组就变成：
$b[l] + c$ , $b[r+1] - c$ 即可。

通常的构造方式是：
$b_i = a_i - a_{i-1}$

某些时候，我们无需构造出整个 b 数组，而是直接将 b 初始化为 0。
而 a 对应的构造 b 其实就是在 0 的基础上进行 n 次添加操作，每次操作为 $[i, i]$ 加上 $a_i$ 即可。这样可以简化程序。
```python
def insert(l, r, c):
    b[r+1] -= c
    b[l] += c

if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        insert(i, i, a[i])
    
    for i in range(m):
        l, r, c = map(int, input().split())
        
        insert(l, r, c)
    
    for i in range(1, n+1):
        b[i] += b[i-1]
        print(b[i], end=" ")
```

2 维差分的构造和 1 维的相同。$a_{ij}$ 等于 $b_{ij}$ 的前缀和。
```python
def insert(x1, y1, x2, y2, c):
    b[x1][y1] += c
    b[x1][y2+1] -= c
    b[x2+1][y1] -= c
    b[x2+1][y2+1] += c
    

if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    b = [[0]*(m+2) for i in range(n+2)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
        
    for i in range(1, n+1):
        for j in range(1, m+1):
            insert(i, j, i, j, a[i][j])
    
    
    for i in range(q):
        x1, y1, x2, y2, c = map(int, input().split())
        
        insert(x1, y1, x2, y2, c)
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]
            
            print(b[i][j], end= " ")
        
        print("")
```


**应用题**：
https://www.acwing.com/problem/content/102/

根据题意，我们发现题目的要求和差分技巧很吻合。
最后期望得到一个序列： $x, x, ... , x$
假设差分数组为：

$b_1 = a_1$

$b_2 = a_2 - a_1$

...

$b_n = a_n - a_{n-1}$


要使最终数列的值都一样，转换成 b 数组即为：
$b_1 = x$, $b_i = 0, i \in [2, n]$

而对 $[l, r]$ 范围内整体加一或减一，则只需要 $b[l] += 1$, $b[r+1] -= 1$

我们分为 4 种情况：
1. $2 <= l <= r <= n-1$, 那么我们可以同时操作两次 $b[2, n]$ 
2. $l = 1, r \in [1, n-1]$，那么我们可以操作一次 $b[2, n]$, 一次 $b[1]$
3. $r = n, l \in [2, n]$, 那么我们可以操作一次 $b[2, n]$, 一次 $b[n+1]$
4. $r = n, l = 1$, 那么我们可以操作一次 $b[1]$, 一次 $b[n+1]$, 无意义

从贪心角度来看，我们应该尽量多的操作 情况 1，因为可以同时将 $b[2, n]$ 范围内的数加一减一来抵消。
假设 $b[2, n]$ 正数和为 p， 负数和转换成正数为 q

那么至少需要操作次数为 $max(p, q)$
最终得到的序列只取决于 $b_1$， 也就是 操作 2。我们将剩下的操作分配给操作 2 和 3，$abs(p-q)+1$ 中可能。

```python
def insert(l, r, c):
    b[l] += c
    b[r+1] -= c
    

if __name__ == "__main__":
    n = int(input())
    
    a = [0] * (n+1)
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        a[i] = int(input())
        insert(i, i , a[i])
    
    p = q = 0
    
    for i in range(2, n+1):
        if b[i] > 0: p += b[i]
        else: q -= b[i]
    
    print(max(p, q))
    print(abs(p-q) + 1)
```


[acwing 101. 最高的牛](https://www.acwing.com/problem/content/103/)

题目分析：
1. 已知最高的牛是 p，且身高是 H
2. 给 M 对关系，可以知悉 A 和 B 的相对关系，也就是 $[A, B]$ 之间的身高要比 $A, B$ 至少少一。

因此，我们假定所有人的初始身高都是 0，每一对关系，相当于对区间中的元素都减 1。且最后 p 的值一定仍然是 0。已知 p 的身高，也就知道其他元素的身高了。

如果采用朴素做法，那么时间复杂度会达到 $O(NM)$ 级别。

此时，可以采用前缀和的逆运算差分技巧