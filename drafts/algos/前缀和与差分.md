
## 前缀和
前缀和算是算法题目中和 **区间** 相关题目的特殊技巧之一。
其可以在 $O(1)$ 的范围内获取任意区间范围 (比如 $[l, r]$)  的和，朴素做法是 $O(n)$ 复杂度。 

### 模板题目
https://www.acwing.com/problem/content/797/

假设原始数组为 a，长度为 n（下标从 1 开始计算）。则对应的前缀和数组 $s[i] = a[1] + a[2] + .... + a[i]$。
则 $[l, r]$ 的和为 $s[r] - s[l-1]$

> 下标从 1 开始计算是为了避免边界情况，比如我们想要求 $[1, r]$ 的和，从 0 开始计算的话会没法统一 $s[l-1] = s[-1]$,在程序上面非法。

```python
if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    s = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    for i in range(1, n+1):
        s[i] = s[i-1] + a[i]
        
    while m:
        
        l, r = map(int, input().split())
        
        print(s[r]-s[l-1])
        
        m -= 1
```

将数组扩展到二维矩阵，就得到了二维前缀和的技巧。其可以在 $O(1)$ 时间复杂度获得任意子矩阵的和。
为了简化边界情况，同样我们的下标从 1 开始计算。
$s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]$ 得到
https://www.acwing.com/problem/content/798/

```python
if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    s = [[0] * (m+1) for i in range(n+1)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]
    
    while q:
        x1, y1, x2, y2 = map(int, input().split())
        
        print(s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1])
        
        q -= 1
```


我们来看下 **前缀和** 的技巧应用：
[1230. K 倍区间](https://www.acwing.com/problem/content/1232/)

题目问： 连续子序列和是 K 倍数的个数

转换成公式就是： $(sum[j] - sum[i-1]) \ mod \ k = 0$.

朴素做法是什么？
> 枚举 i 和 j，然后看 $[i, j]$ 是否满足要求。时间复杂度 $O(n^2)$，显然会超时。

那么我们是否由更加简单的做法呢？
这里会运用到一些数学上的技巧。我们可以将任意的区间和分成 $k$ 类，具体分类方式根据 $x \ mod \ k$ 来划分。

那么每一类中的任意两个元素都可以构成一个 K 倍区间。证明如下：
**假设是第 i 类元素中的两个元素，根据划分方式可以得到：**

$x = i + a * k$ 和 $y = i + b * k(y > x)$，那么 $y-x = (b-a)k$ ，证明完毕。

也就是一个组合数计算而已。

```python
from collections import defaultdict

if __name__ == "__main__":
    n, k = map(int, input().split())
    
    s = [0] * (n + 1)
    
    for i in range(1, n+1):
        s[i] = s[i-1] + int(input())
    
    d = defaultdict(int)
    
    d[0] = 1
    
    res = 0
    for i in range(1, n+1):
        t = s[i] % k
        res += d[t]
        
        d[t] += 1
    
    print(res)
```



**衍生题目**：
https://www.acwing.com/problem/content/description/101/

思路：由于边界上的点不算，所以我们可以通过稍微偏移 R 矩阵来达到内部目的，也就变成了 R-1 的矩阵（包含边界）。
这样就变成了二维前缀和问题。


## 差分
> 差分也被称为前缀和的逆运算，通常也被分为 1 维 和 2 维

假设存在一个整数数组 a, 我们需要构造一个数组 b，使得：
$a_i = b_1 + b_2 + ... + b_i$。

这样的构造可以用来解决一类问题：
将对区间 $[l, r]$ 范围内都加上一个数的时间复杂度由 $O(n)$ 降低到 $O(1)$。

举例， a $[l, r]$ 范围都加上 C, 转换到 b 数组就变成：
$b[l] + c$ , $b[r+1] - c$ 即可。

通常的构造方式是：
$b_i = a_i - a_{i-1}$

某些时候，我们无需构造出整个 b 数组，而是直接将 b 初始化为 0。
而 a 对应的构造 b 其实就是在 0 的基础上进行 n 次添加操作，每次操作为 $[i, i]$ 加上 $a_i$ 即可。这样可以简化程序。
```python
def insert(l, r, c):
    b[r+1] -= c
    b[l] += c

if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        insert(i, i, a[i])
    
    for i in range(m):
        l, r, c = map(int, input().split())
        
        insert(l, r, c)
    
    for i in range(1, n+1):
        b[i] += b[i-1]
        print(b[i], end=" ")
```

2 维差分的构造和 1 维的相同。$a_{ij}$ 等于 $b_{ij}$ 的前缀和。
```python
def insert(x1, y1, x2, y2, c):
    b[x1][y1] += c
    b[x1][y2+1] -= c
    b[x2+1][y1] -= c
    b[x2+1][y2+1] += c
    

if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    b = [[0]*(m+2) for i in range(n+2)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
        
    for i in range(1, n+1):
        for j in range(1, m+1):
            insert(i, j, i, j, a[i][j])
    
    
    for i in range(q):
        x1, y1, x2, y2, c = map(int, input().split())
        
        insert(x1, y1, x2, y2, c)
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]
            
            print(b[i][j], end= " ")
        
        print("")
```


**应用题**：
https://www.acwing.com/problem/content/102/

根据题意，我们发现题目的要求和差分技巧很吻合。
最后期望得到一个序列： $x, x, ... , x$
假设差分数组为：

$b_1 = a_1$

$b_2 = a_2 - a_1$

...

$b_n = a_n - a_{n-1}$


要使最终数列的值都一样，转换成 b 数组即为：
$b_1 = x$, $b_i = 0, i \in [2, n]$

而对 $[l, r]$ 范围内整体加一或减一，则只需要 $b[l] += 1$, $b[r+1] -= 1$

我们分为 4 种情况：
1. $2 <= l <= r <= n-1$, 那么我们可以同时操作两次 $b[2, n]$ 
2. $l = 1, r \in [1, n-1]$，那么我们可以操作一次 $b[2, n]$, 一次 $b[1]$
3. $r = n, l \in [2, n]$, 那么我们可以操作一次 $b[2, n]$, 一次 $b[n+1]$
4. $r = n, l = 1$, 那么我们可以操作一次 $b[1]$, 一次 $b[n+1]$, 无意义

从贪心角度来看，我们应该尽量多的操作 情况 1，因为可以同时将 $b[2, n]$ 范围内的数加一减一来抵消。
假设 $b[2, n]$ 正数和为 p， 负数和转换成正数为 q

那么至少需要操作次数为 $max(p, q)$
最终得到的序列只取决于 $b_1$， 也就是 操作 2。我们将剩下的操作分配给操作 2 和 3，$abs(p-q)+1$ 中可能。

```python
def insert(l, r, c):
    b[l] += c
    b[r+1] -= c
    

if __name__ == "__main__":
    n = int(input())
    
    a = [0] * (n+1)
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        a[i] = int(input())
        insert(i, i , a[i])
    
    p = q = 0
    
    for i in range(2, n+1):
        if b[i] > 0: p += b[i]
        else: q -= b[i]
    
    print(max(p, q))
    print(abs(p-q) + 1)
```


[acwing 101. 最高的牛](https://www.acwing.com/problem/content/103/)

题目分析：
1. 已知最高的牛是 p，且身高是 H
2. 给 M 对关系，可以知悉 A 和 B 的相对关系，也就是 $[A, B]$ 之间的身高要比 $A, B$ 至少少一。

因此，我们假定所有人的初始身高都是 0，每一对关系，相当于对区间中的元素都减 1。且最后 p 的值一定仍然是 0。已知 p 的身高，也就知道其他元素的身高了。

如果采用朴素做法，那么时间复杂度会达到 $O(NM)$ 级别。

此时，可以采用前缀和的逆运算差分技巧：
