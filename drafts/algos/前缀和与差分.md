
## 前缀和
前缀和算是算法题目中和 **区间** 相关题目的特殊技巧之一。
其可以在 $O(1)$ 的范围内获取任意区间范围 (比如 $[l, r]$)  的和，朴素做法是 $O(n)$ 复杂度。 

https://leetcode-cn.com/circle/discuss/SrePlc/

### 模板题目
https://www.acwing.com/problem/content/797/

假设原始数组为 a，长度为 n（下标从 1 开始计算）。则对应的前缀和数组 $s[i] = a[1] + a[2] + .... + a[i]$。
则 $[l, r]$ 的和为 $s[r] - s[l-1]$

> 下标从 1 开始计算是为了避免边界情况，比如我们想要求 $[1, r]$ 的和，从 0 开始计算的话会没法统一 $s[l-1] = s[-1]$,在程序上面非法。

```python
if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    s = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    for i in range(1, n+1):
        s[i] = s[i-1] + a[i]
        
    while m:
        
        l, r = map(int, input().split())
        
        print(s[r]-s[l-1])
        
        m -= 1
```

将数组扩展到二维矩阵，就得到了二维前缀和的技巧。其可以在 $O(1)$ 时间复杂度获得任意子矩阵的和。
为了简化边界情况，同样我们的下标从 1 开始计算。
$s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1]$ 得到
https://www.acwing.com/problem/content/798/

```python
if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    s = [[0] * (m+1) for i in range(n+1)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]
    
    while q:
        x1, y1, x2, y2 = map(int, input().split())
        
        print(s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1])
        
        q -= 1
```


我们来看下 **前缀和** 的技巧应用：
[1230. K 倍区间](https://www.acwing.com/problem/content/1232/)

题目问： 连续子序列和是 K 倍数的个数

转换成公式就是： $(sum[j] - sum[i-1]) \ mod \ k = 0$.

朴素做法是什么？
> 枚举 i 和 j，然后看 $[i, j]$ 是否满足要求。时间复杂度 $O(n^2)$，显然会超时。

那么我们是否由更加简单的做法呢？
这里会运用到一些数学上的技巧。我们可以将任意的区间和分成 $k$ 类，具体分类方式根据 $x \ mod \ k$ 来划分。

那么每一类中的任意两个元素都可以构成一个 K 倍区间。证明如下：
**假设是第 i 类元素中的两个元素，根据划分方式可以得到：**

$x = i + a * k$ 和 $y = i + b * k(y > x)$，那么 $y-x = (b-a)k$ ，证明完毕。

也就是一个组合数计算而已。

```python
from collections import defaultdict

if __name__ == "__main__":
    n, k = map(int, input().split())
    
    s = [0] * (n + 1)
    
    for i in range(1, n+1):
        s[i] = s[i-1] + int(input())
    
    d = defaultdict(int)
    
    d[0] = 1
    
    res = 0
    for i in range(1, n+1):
        t = s[i] % k
        res += d[t]
        
        d[t] += 1
    
    print(res)
```



**衍生题目**：
https://www.acwing.com/problem/content/description/101/

思路：由于边界上的点不算，所以我们可以通过稍微偏移 R 矩阵来达到内部目的，也就变成了 R-1 的矩阵（包含边界）。
这样就变成了二维前缀和问题。


1. [leetcode 560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

经典的**前缀和+哈希表优化**的题目。

用数据结构来优化算法是常见的一种技巧。比如上面这一类题目就是经典的通过哈希表来优化前缀和的计算过程。


其他题目
1. [leetcode 525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)
2. [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

另外，我们也可以直接通过本题将题目扩展到求方案数。

哈希表优化: 比如两数之和

3. [leetcode 1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

题目表面来看是一道 **二维前缀和** 的问题。

题目要求我们枚举所有的子矩阵，那么该如何确定一个子矩阵呢？
1. 通过左上角和右下角可以唯一确定一个子矩阵
2. 通过上下左右四条边可以唯一确定一个子矩阵

先来分析第一个方法：
枚举所有的左上角和右下角的时间复杂度是 $O(n^2*m^2)$，而计算具体子矩阵的和可以通过二维前缀和优化到 $O(1)$, 因此总时间复杂度为 $O(n^2m^2)$, 对应的数据量是 $10^8$，具有超时的风险。

第二个方案的分析：
枚举 4 条边的复杂度是 $O(n^2m^2)$，但是通过哈希表可以加快第 4 条边的搜索。具体过程如下：
1. 枚举上下边界
2. 枚举右边界，来查看是否有合适的左边界。而这个具体的过程就是上题的过程。已知列的数组，求连续子数组的和是 target 的个数。而我们可以通过动态维护列的和来快速求出 target的个数。

3. [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

本题是经典的：一维数组求最大连续子数组和+加限制+扩展到二维

首先**一维最大连续子数组和**常用解法：
1. 动态规划：$f(i)$ 表示以 i 结尾的最长连续子数组和，时间复杂度为 $O(n)$
   - $f(i) = max(f(i-1)+a[i], a[i])$

2. 枚举+剪枝优化：如何求以 i 结尾的最长连续子数组和呢？我们知道，前缀和可以在 $O(1)$ 求出任意区间的和，$s[i] - s[x]$ 表示 $[x+1, i]$ 整个区间。$s[i]$ 是定值，要是 $s[i] - s[x]$ 最大，也就是要使 $s[x]$ 尽量最小，也就是我们要求在 $[0, i-1]$ 区间的 s 的最小值。朴素方式是枚举这个区间，时间复杂度是 $O(n)$，但是我们发现最小值可以由前一个阶段的最小值和当前的值比较求出，也就是将前面阶段的最小值通过一个变量保存。这样避免重复计算，时间复杂度降低到 $O(1)$。总的时间复杂度是 $O(n)$

**一维最大连续子数组和+上界**：
此时，上述动态规划的方式就无法解决了。因为在子问题阶段无法通过简单方式来定义**上界** 这个维度信息。

换句话说，如果我们以子数组的结尾作为阶段，没有办法通过已求的阶段解来求出当前阶段的解，也就是不满足最优子结构特性。

那么第二种方式呢？
我们期望找出最接近 k 的子数组大小，换句话说也就是 $s[i] - s[x]$ 要接近 k，也就是 $abs(s[i] - s[x] - k)$ ，因为 $s[i] - k$ 是定值，我们需要使上面的公式最小，也就是期望找到一个 $s[x]$ 最接近 $s[i] - k$。

如果本身数组元素没有负数的话，我们可以根据**前缀和**的非严格单调递增特性，进行二分查找在 $logn$ 时间求出最接近的值。

但是如果数组元素存在负数，那么前缀和本身就失去了单调特性，这样我们可以通过**有序集合**（具体原理可以用红黑树来做）来维护遍历过的位置，这样我们也可以在 $logn$ 时间内求出最接近的值，并且在 $logn$ 内维护有序集合。

扩展到二维该如何处理呢？

正如上一题所提到的一样，我们可以枚举上下界来解决问题。
当固定了上界后，下界可以以 +1 的递增方式枚举。这样，我们可以在 $O(n)$ 时间内快速求的上下界固定的每一列的和。也就是说，我们在上下界固定时，将问题转换成了**一维求最大接近 k 的子数组和**，而这个问题的解法如上是 $O(nlogn)$，因此总的时间复杂度变成了 $O(m^2*nlogn)$

如果向要在优化，就要比较 m，n 的大小来定具体固定上下还是左右的边界。

空间复杂度为 $O(max(m, n))$

有序集合：
- Java 中可以通过 TreeSet 解决
- c++ set 解决
- python3 sortedcontainers.SortedList


#### 最大、最小前缀和

> 题目类型：求给定 n 个元素中，最小/最大 k 个数的和。

最小 k 个数 = 大顶堆；最大 k 个数 = 小顶堆。时间复杂度降为 $O(n)$

1. [2163. 删除元素后和的最小差值](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/)

题目等价于：
    - 在 `[n-1, 2n-1]` 中选择一个 k, 求 `[0...k]`中的最小 n 个数，求[k+1...3*n-1] 中的最大 n 个数。求这些 k 中让sumFirst - sumSecond 最小的 k

2. [2167. 移除所有载有违禁货物车厢所需的最少时间](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/)

前缀和+dp => 贪心+前缀和
## 差分
> 差分也被称为前缀和的逆运算，通常也被分为 1 维 和 2 维

假设存在一个整数数组 a, 我们需要构造一个数组 b，使得：
$a_i = b_1 + b_2 + ... + b_i$。

这样的构造可以用来解决一类问题：
将对区间 $[l, r]$ 范围内都加上一个数的时间复杂度由 $O(n)$ 降低到 $O(1)$。

举例， a $[l, r]$ 范围都加上 C, 转换到 b 数组就变成：
$b[l] + c$ , $b[r+1] - c$ 即可。

通常的构造方式是：
$b_i = a_i - a_{i-1}$

某些时候，我们无需构造出整个 b 数组，而是直接将 b 初始化为 0。
而 a 对应的构造 b 其实就是在 0 的基础上进行 n 次添加操作，每次操作为 $[i, i]$ 加上 $a_i$ 即可。这样可以简化程序。
```python
def insert(l, r, c):
    b[r+1] -= c
    b[l] += c

if __name__ == "__main__":
    n, m = map(int, input().split())
    a = [0] * (n+1)
    
    a[1:n+1] = map(int, input().split())
    
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        insert(i, i, a[i])
    
    for i in range(m):
        l, r, c = map(int, input().split())
        
        insert(l, r, c)
    
    for i in range(1, n+1):
        b[i] += b[i-1]
        print(b[i], end=" ")
```

2 维差分的构造和 1 维的相同。$a_{ij}$ 等于 $b_{ij}$ 的前缀和。
```python
def insert(x1, y1, x2, y2, c):
    b[x1][y1] += c
    b[x1][y2+1] -= c
    b[x2+1][y1] -= c
    b[x2+1][y2+1] += c
    

if __name__ == "__main__":
    n, m, q = map(int, input().split())
    
    a = [[0] * (m+1) for i in range(n+1)]
    b = [[0]*(m+2) for i in range(n+2)]
    
    for i in range(1, n+1):
        a[i][1:m+1] = map(int, input().split())
        
    for i in range(1, n+1):
        for j in range(1, m+1):
            insert(i, j, i, j, a[i][j])
    
    
    for i in range(q):
        x1, y1, x2, y2, c = map(int, input().split())
        
        insert(x1, y1, x2, y2, c)
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]
            
            print(b[i][j], end= " ")
        
        print("")
```


**应用题**：
https://www.acwing.com/problem/content/102/

根据题意，我们发现题目的要求和差分技巧很吻合。
最后期望得到一个序列： $x, x, ... , x$
假设差分数组为：

$b_1 = a_1$

$b_2 = a_2 - a_1$

...

$b_n = a_n - a_{n-1}$


要使最终数列的值都一样，转换成 b 数组即为：
$b_1 = x$, $b_i = 0, i \in [2, n]$

而对 $[l, r]$ 范围内整体加一或减一，则只需要 $b[l] += 1$, $b[r+1] -= 1$

我们分为 4 种情况：
1. $2 <= l <= r <= n-1$, 那么我们可以同时操作两次 $b[2, n]$ 
2. $l = 1, r \in [1, n-1]$，那么我们可以操作一次 $b[2, n]$, 一次 $b[1]$
3. $r = n, l \in [2, n]$, 那么我们可以操作一次 $b[2, n]$, 一次 $b[n+1]$
4. $r = n, l = 1$, 那么我们可以操作一次 $b[1]$, 一次 $b[n+1]$, 无意义

从贪心角度来看，我们应该尽量多的操作 情况 1，因为可以同时将 $b[2, n]$ 范围内的数加一减一来抵消。
假设 $b[2, n]$ 正数和为 p， 负数和转换成正数为 q

那么至少需要操作次数为 $max(p, q)$
最终得到的序列只取决于 $b_1$， 也就是 操作 2。我们将剩下的操作分配给操作 2 和 3，$abs(p-q)+1$ 中可能。

```python
def insert(l, r, c):
    b[l] += c
    b[r+1] -= c
    

if __name__ == "__main__":
    n = int(input())
    
    a = [0] * (n+1)
    b = [0] * (n+2)
    
    for i in range(1, n+1):
        a[i] = int(input())
        insert(i, i , a[i])
    
    p = q = 0
    
    for i in range(2, n+1):
        if b[i] > 0: p += b[i]
        else: q -= b[i]
    
    print(max(p, q))
    print(abs(p-q) + 1)
```


[acwing 101. 最高的牛](https://www.acwing.com/problem/content/103/)

题目分析：
1. 已知最高的牛是 p，且身高是 H
2. 给 M 对关系，可以知悉 A 和 B 的相对关系，也就是 $[A, B]$ 之间的身高要比 $A, B$ 至少少一。

因此，我们假定所有人的初始身高都是 0，每一对关系，相当于对区间中的元素都减 1。且最后 p 的值一定仍然是 0。已知 p 的身高，也就知道其他元素的身高了。

如果采用朴素做法，那么时间复杂度会达到 $O(NM)$ 级别。

此时，可以采用前缀和的逆运算差分技巧

## 例题：
1. https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/ 简单前缀和
2. https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/

朴素做法：枚举所有的切割，然后判断。时间复杂度为 $O(n^2)$

如何来优化呢？
- 优化切割。已经时最优了
- 优化判断。期望快速获得两个子字符串的不同字符的个数。我们可以通过前缀和数组或者递推线性求得 $[1, i]$ 的不同字符串个数，只需要判断 $cnt[i+1]$ 是否是 0 即可。 


3. https://leetcode-cn.com/problems/can-make-palindrome-from-substring/ 频次前缀和/ 状态压缩+前缀和

4. https://leetcode-cn.com/problems/sum-of-floored-pairs/ 频次前缀和+线性筛素数
5. [leetcode 1124. 表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/) 前缀和+单调栈
6. [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/) 状态压缩+前缀和

题目要求：最长的子字符串，且该子串的 $a,e,i,o,u$ 只有偶数个

朴素做法是：
枚举所有的子串，判断子串是否满足要求。时间复杂度为 $O(n^3)$，超时。

我们可以通过前缀和优化子串的判断过程：可以分别用 $f[i][0,..4]$ 表示 $a,e,i,o,u$ 的在 $s[0, ...,i]$ 的个数，这样可以优化掉一维，将时间优化到 $O(n^2)$。

我们发现，通过 5 个数组来分别表示 $a,e, i, o, u$ 太过于麻烦，且我们无需知道具体的个数，只需要知道奇偶性就可（这种 **a是偶数** 条件在算法中很常见，比如一类并查集题目-带扩展域的并查集），这样我们可以通过 $0, 1$ 来表示奇偶性，并且通过异或来表示增加元素。

这样，我们可以通过状态压缩，将 5 个数组压缩到一个数组即可，比如 $10010$，表示 a, i 是奇数，其他的是偶数。
如果低 $s[i+1]$ 是 a 的话，我们只需要将 $f[i] ^ (1<<4)$ 即可，就可以在 $O(1)$ 的时间范围内求得新的奇偶性。

这样，我们优化了算法的常系数和空间。

要找出最长的子串，也就是在前缀和数组中找出两个元素，设为 $s[i], s[j]$ 两者的所有元素的奇偶性相同，也就是 $s[i] = s[j]$，这样我们可以通过一个 map 来维护已经出现过的 $s[i]$, 这样又去掉了一维，将总体的时间复杂度降低到了 $O(n)$

5. [leetcode 1542. 找出最长的超赞子字符串](https://leetcode-cn.com/problems/find-longest-awesome-substring/)前缀和+状态压缩

题目要求：求出一个子串，子串非空，且里面所有字符的奇偶性最多只能由一个奇，其余都是偶数性。

这样题目转换成了上面的题目：

稍微复杂一点的是，可能存在一个奇数，我们先通过枚举的方式来试试看：
1. 全部都是偶数的时候。和上题一模一样
2. 存在一个奇数，可以通过枚举所有的元素，该元素就是那唯一的奇数

这样我们通过 $2^10-1$ 来表示 $0, ..., 9$，时间复杂度为 $O(10n) = 10^6$

6. [1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

朴素做法：

枚举所有的子矩阵，分别判断每个子矩阵是否满足要求。时间复杂度为 $O(n^5)$。

可以通过二维前缀和将判断子矩阵的复杂度降低到 $O(1)$，总时间复杂度变为 $O(n^4) = 10^8$

我们再来看一下是否存在隐藏的特性可以帮助我们优化复杂度，上面的解法是通过枚举左上端点和右下端点来确定一个子矩阵的。

我们还有另外一种方法，枚举四条边来确定一个子矩阵。朴素做法仍然是 $O(n^4)$

但是，我们固定上下界之后（枚举上界），可以在 $O(n)$ 时间内获得每个长为 1，高为 $ceil-floor$ 的矩阵面积。下面我们需要确定合适的左右边界。我们是否能够优化其中的枚举过程呢？

假设我们枚举右边界，是否能够快速确定满足要求的左边界的个数呢？

答案是能的。我们在求出每个宽度为 1，高度为 h 的子矩行的面积之后，枚举左右边界就变成了在一个高度数组中，找到所有的连续子数组，其和为 target。就变成了 **一维前缀和+哈希表** 的做法。

这样，我们就有优化了复杂度。总时间复杂度为 $n^3$

7. [面试题 17.24. 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)

题型和上面类似。只是我们只需要用一个变量到目前为止最小值的位置。

8. [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

题目要求：找出所有的子矩阵，其和不超过 k，求符合该要求的子矩阵的个数。

如何快速获得符合要求的子矩阵呢？本题仍然是上面思想的变形。

1. 同样枚举上下边界
2. 枚举右边界，通过二分来快速判断符合要求的左边界的位置

因此，我们需要通过**有序集合**来维护已经枚举过的位置，维护成本为 $logn$。

总的时间复杂度为 $O(n^3logn)$ 满足要求。


[1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)

朴素做法直接枚举所有的左上端点，然后枚举对应的所有长度，来求解答案。时间复杂度为 $O(nm*min(n, m))$, 理论上不会超时。

由于矩阵所有的元素都是非负的，因此，二维前缀和是非负的，并且沿着横坐标、纵坐标、对角线递增。因此，我们可以通过二分查找求出最长的符合要求的矩阵。

枚举右下角，二分查找最大的 l，使得其矩阵和 $\leq threshold$。总时间复杂度降低到 $O(nm*log(min(n, m)))$

是否还能够更加优化呢？

本质上二分查找也是优化枚举。由于本题的所有元素都是非负，也就是前缀和满足单调性。那么有两个特性：
1. 如果 $c$ 是左上角为 (i, j) 并且矩阵和小于等于 threshold 的最长长度。那么显然 $x > c$ 都不满足要求。
2. 而由于只要求最长的长度，我们在枚举其他的左上角时，那么 $[0, c)$ 就没必要枚举了。

总时间复杂度优化到 $O(mn)$

[1314. 矩阵区域和](https://leetcode-cn.com/problems/matrix-block-sum/)

本题是一道二维前缀和的问题。
$ans[i]$ 是 $(max(0, i-k), max(0, j-k)), (min(m-1, i+k), min(n-1, j+k))$ 的矩阵和

直接朴素枚举所有的中心点即可。时间复杂度为 $O(mn)$

[1139. 最大的以 1 为边界的正方形](https://leetcode-cn.com/problems/largest-1-bordered-square/)

首先，朴素做法是什么？

枚举所有的正方形，然后判断该正方形是否满足限制条件，满足再看判断能否更新答案。时间复杂度为 $O(n^4)$，可能会超时。

那么我们能否快速判断某个正方形是否满足要求呢？

是可以的，我们可以填求出任意点 $(i, j)$，通过递推的方式来求出从该点出发分别沿着横坐标向右和纵坐标向下的最长连续 1 的个数。$row[i][j]$ 和 $col[i][j]$，按照下标倒序求解。时间复杂度为 $O(n^2)$

具体剪枝过程为：
1. 枚举所有的左上端点，枚举所有可能的边长 x（边长从大到小，也就是枚举所有可能的正方形），设4个端点为 $(i1, j1), (i2, j2) , (i3, j3), (i4, j4)$（方向为从左上顺时针转动）
    - $row[i1][j1] >= x \& col[i1][j1] >= x \& col[i2][j2] >= x \& row[i4][j4] >= x$ 即可判断是否满足要求

总时间复杂度为 $O(n^3)$， 满足数据范围要求。

是否能继续优化？

我们发现，对于每个左上端点，边长都从 $[1, n]$ 遍历一遍。这个过程有很多无意义的遍历，因为我们要求的是最长的边长。因此，每次更新完最长边长，后面的未枚举左上端点就没必要枚举所有的边长了，而是从 $[ans+1, n]$ 进行枚举。这样最内层的循环次数减少。最坏 $O(n^3)$, 最好 $O(n^2)$。

另外也可以正序来判断，如果左边界和上边界不满足要求，则遍历下一个端点。如果只是下边界和右边界不满足要求，继续判断更大的边长。复杂度和上面类似。


根据递推公式，我们可以通过滚动数组，可以将空间从 $O(mn)$ 优化到 $O(min(n, m))$, 比如从右下角开始遍历

[leetcode 1352. 最后 K 个数的乘积](https://leetcode-cn.com/problems/product-of-the-last-k-numbers/)

根据题意，我们想要知道任意区间的乘积。我们期望高效率的得出最终的答案。从前缀和的计算方式，我们是否能够在 $O(1)$ 的时间内求出对用的区间乘积呢。

假设 $s[i]$ 表示 $[0, .. , i]$ 的所有数的乘积那么 $[i, j]$ 就是 $s[j] / s[i-1]$ 就得到了最终的答案。

但是值得注意的是，除法和加法是不一样的，因为除数不能为 0。如果数组中有元素的值为 0，那么表示前缀和的值可能为 0，因此我们需要特判。

由于本身，`getProduct` 是动态获得的，因此，我们在遇到 0 的时候，直接将前缀积数组置为空，来表示从这个数开始，$[i, i+k-1]$ 范围内结尾的数的 乘积一定是 0.特判就好了


前缀异或：
1. [leetcode 1310. 子数组异或查询](https://leetcode-cn.com/problems/xor-queries-of-a-subarray/)
2. [1442. 形成两个异或相等数组的三元组数目](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)

先来看朴素做法：
枚举所有的 i,j,k, 然后判断 $s[i,j)$ 和 $s[j, k]$ 两个区间的异或是否相等。

枚举的时间复杂度为 $O(n^3)$, 判断的复杂度可以通过前缀异或和降低到 $O(1)$。总的时间复杂度约 $2.7*10^7$，可能会超时。

再挖掘下特性，如果一个区间 $[i, j]$ 能够通过 k 分隔成 $[i, k]$ 和 $[k+1, j]$ 这两个区间，且两者的异或相等。也就是 $a \oplus b = 0$,也就是 $s[i,j]$ 为 0。我们可以在 $O(n^2)$ 内获得所有该特性的区间。

还有一个问题，该如何找到这个 k，我们再看一下：
$a[i] \oplus a[i+1] \oplus ... a[j] = 0$ ，任意划分一下， $a[i] \oplus ... a[k]$ 一定等于 $a[k+1] \oplus ... a[j]$, 共有 $j-i$ 种划分可能

这样，我们就在 $O(n^2)$ 时间内求得了答案。

是否还能够优化呢？我们再来看枚举 $s[i, j]$ 为 0的所有可能时，根据异或的特性， $s[i-1] = s[j]$。我们可以通过哈希表来存储对应已经处理过的 $s$。

具体该如何存储呢？因为需要知道具体有几个相同的值，且要知道所有的 $j-i$，也就是 $j*cnt - (i_1+i_2+...+i_{cnt})$,
因此我们存储为 $(cnt, sum)$ 即可。
这样通过哈希表将时间复杂度降低到 $O(n)$

[1738. 找出第 K 大的异或坐标值](https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/)

二维前缀异或+堆/快速选择


有时候，我们需要前缀和+后缀和同时处理求出对应的答案

[724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

1. [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

朴素想法： $ans[i] = l[i-1] * r[i+1]$

这样我们可以在 $O(n)$ 时间内解决。进阶需要我们优化空间。

首先，我们可以优化掉 r 数组，直接将 r 数组的求解放到答案的求解遍历中，也就是动态求解，而不是预处理。

那么如何优化掉 l 数组呢？我们可以直接利用 ans 数组存储对应的 l 数组即可。


[1444. 切披萨的方案数](https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/)

朴素想法：

枚举 k 种切法，然后组合每次切法的位置，最后判断切出去的位置是否能够满足要求。算法复杂度接近 $2^k*n*m*nm$。

通过前缀和预处理，可以优化判断切出去的部分是否满足要求的复杂度，从 $O(mn)$ 降低到 $O(1)$, 

总的时间复杂度不太好计算，至少是 $O(2^k*C_k^{k/2}*m)$, 计算量级达到 $1.5 * 10^7$ 理论上能够满足要求。

实测，leetcode 会在最后一个测试用例超时。

如何解决呢？添加一个辅助数组缓存一下。减少部分重复计算。时间复杂度降低到 $O(kmn)$ - 记忆化的 dfs

每次切割后，我们会发现，切割后剩下的矩形，右下角是不会变化的，变化的只是左下角。新左下角到右下角切 i 刀，和原始问题是一样的。
因此可以试着用 dp 来解决。

设 $s(i, j, t)$ 表示从 $(i, j)$ 开始切 t 刀的方案数。那么 $f(0, 0, k-1)$ 就是答案。

初始化： $f(x, y, 0) = 1, 当且仅当 (x,y) 到 右下角里面至少有一个 A$

状态转移方程呢？

$f(i, j, t) = f(x, j, t-1) + f(j, y, t-1), x, y 满足切割要求$

时间复杂度为 $O(mnk*(m+n))$, 量级为 $2.5*10^6$




