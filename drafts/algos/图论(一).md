## 1. 基本概念

**dp 一般可以转化为 拓扑序上的最短路问题。**

1. 拓扑排序

拓扑排序对应着 DAG 图，也就是有向无环图。目的是将图中的所有顶点排成线性序列，使得途中任意一对顶点 $u$ 和 $v$, 如果 $<u, v> \in E$，则 u 在线性序列中必须出现在 v 之前。

扩展：
1. 只有 DAG 图才会有拓扑序
2. 对于一个 DAG，可能存在多个拓扑序

算法过程：
1. 建立图，统计每个顶点 v 的入度，将入度为 0 的所有元素入队
2. 循环取出对头元素，假设为 t
   - 将 t 发出的所有边对应的顶点入度减 1，如果当前顶点入度被减为 0，则将该顶点入队
3. 则出队的顺序就是拓扑排序。如果出队元素个数小于顶点个数，则表示图中有环，不存在拓扑序。

[acwing 848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)


## 2. 单源最短路
1. 边权非负
   - 朴素 dijkstra，时间复杂度 $O(n^2)$
   - 堆优化的 dijkstra, 时间复杂度 $O((m+n)logn) = O(mlogm)$
2. 有负权边
   - bellman-ford: $O(nm)$
   - spfa: 平均 $O(m)$, 最坏 $O(nm)$

基础算法理解并不难，题目的难点在于如何将问题转化和抽象成对应的算法模型。

dijkstra 算法的基础核心是贪心，需要确保每个边权都是正的。

下面我们来看下具体的算法：
1. 假设 $d[i]$ 表示源点 1 到 i 的最短距离，初始化为无穷大。则 $d[1] = 0$，$vis$ 数组表示当前顶点是否已经被访问过。
2. 循环 n 次，在每次循环中：
   1. 查找未被访问的顶点中 $d[i]$ 最小的顶点，设为 t。则 $d[t]$ 此时的值即为$1 -> t$ 的最短距离。我们将 $vis[t]$ 标记为 true。
   2. 将 t 关联的边用三角不等式进行更新

为什么需要边权都是正的？

> 确保 dijkstra 算法贪心的正确性。按照 dijkstra 算法只要某个顶点被访问过，则该点到源点的最短距离就确定了。

[acwing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

我们仔细观察会发现，只有在第二步通过 **三角不等式** 进行松弛的时候才会更新 dist 数组。也就是说，只有松弛操作才会影响到最短距离。

因此，我们可以通过最小堆来维护所有的被更新的 $dist[i]$ 这样可以在 $O(1)$ 来获取此时最小的 $dist[i]$。总共更新次数最多是 $m$ 次，而在二叉堆中维护数据的成本是 $O(logn)$，因此松弛操作的复杂度为 $O(mlogm)$。

另外，找到当前没有标记且离源点最近的点的复杂度总共 n 次。因此时间复杂度由最大的决定，总共为 $O(mlogm)$

算法思路为：
1. 最小堆为 q，设 dist 维护 1 到 所有点的最短距离。$dist[1] = 0$,并将 $(dist[1], 1)$ 放入到 q 中。标记数组为 vis。
2. 弹出堆顶元素，设为 t：
   - 如果 t 已经被标记 ，continue
   - 标记 t，并且将 t 关联的所有顶点用三角不等式更新。如果有更新，对应的顶点放入到 q 中




### bellman ford
动态规划思想

bellman ford 算法思想很简洁。其本质是：在第 k 次循环中，所有源点到顶点的最短路径边长数 小于等于 k 的dist都会被更新完成。难点在于如何理解算法的正确性。

在 **算法导论** 当中，是通过数学归纳法来证明的，用到 松弛的收敛定理。

> 定理：对于图 G = (N, E)。对于任意存在最短路径的两个顶点，该最短路径最多只包含 n-1 条边。证明方式，反法，如果存在超过 n-1 条边的最短路径，那么一定存在负权环，也就表示不存在最短路径，证毕。

算法过程如下：
1. 循环 n-1 次
2. 每次循环当中，对 m 条边进行松弛操作

因此，时间复杂度为 $O(nm)$。

> 定理：在第 k 次循环，一定会求出所有最短路径中边数不超过 k 的最短路径。此时边数超过 k 的最短路径也有可能被求出来。s

其可以用来判断是否存在负环：如果在第 n 次循环当中，仍然存在边可以进行松弛操作，那么一定存在负环。

因为进行 n 次循环后，可以找到一条最短路，路径上存在 n+1 个点，根据容斥原理，一定存在一个环，并且这个环减少了路径和，因此是负环。

[AcWing 853. 有边数限制的最短路 ](https://www.acwing.com/activity/content/problem/content/922/1/)
1. 进行 k 次循环，每次循环松弛所有的边。一定可以得出由源点出发经过 k 条边到达对应顶点的当前最短路径和。

避免同层循环互相影响，因此我们需要将 dist 数组进行复制处理。


### spfa 算法
spfa 是国内的叫法，在国际上，该算法被称为基于队列优化的 bellman ford 算法。

其思想是只有被三角不等式进行松弛的顶点才有可能影响到其它顶点。所以我们通过队列维护被更新过的顶点，每次只需要处理这些顶点即可。这样避免每次重复遍历未松弛的边。

其算法步骤为：
1. 设队列为 q，将源点 s入队，`vis[s]` 标记为 true
2. 弹出队头元素，设为 t:
   - `vis[t]` 设为 false，表示队列中没有 t 了
   - 处理 t 发起的每条边，如果某个顶点能够通过三角不等式进行松弛，设为 i，则将 i 放入到队列中，并标记 i
3. 循环进行步骤 2，直到队列为空

值得注意的是，spfa 算法可能会被通过数据构造卡掉。


> 我们可以通过 spfa 算法来判断是否存在负环。

常用方法：
1. 统计每个点的入队次数，如果某个点入队次数到达 n 次，则说明存在负环（表示该点至少被松弛了 n 次，表示一定存在负环）
2. 统计每个点的最大短路中所包含的边数，如果某个点的最短路所包含的边数大于等于 n，也就是表明这条路径存在 n+1 个点，也就是表明存在环。如果该环是正的，那么我们可以去掉该环，得到一个更小的最短路，因此该环一定是负的。

朴素做法是：对于每个点进行一次 spfa，那么平均时间复杂度将达到 $O(nm)$，乘上常系数很容易超时。

更好的做法是，我们可以在原图的基础上增加一个虚拟源点，这样就将多源汇最短路转换成单源最短路问题。从虚拟源点向其他所有点建立一条边权为 0 的边，那么原图有负环等价于新图有环。


### 题目应用
1. [acwing 1127. 香甜的黄油](https://www.acwing.com/problem/content/1129/)

题目解析：
有 n 个点，m 条边。每个点可能有 $x \in [0, k]$ 个物品。选择任意一个点作为终点，那么将所有物品传递到该终点的最小代价和。

n 的范围是 800， m 的范围是 1450。

这里我们直接用朴素的想法即可。
1. 枚举所有的点，设为 i
2. 以 i 为起点，计算该点到其他点的最短距离。然后计算代价和
3. 答案即为所有代价和的最小值。

具体计算最短距离的算法我们可以采用：堆优化的 dijkstra 或者 spfa 都可。


2. [AcWing 1126. 最小花费](https://www.acwing.com/problem/content/1128/)
题目分析：

假设由 A 到 B 的路径构成一个集合。每个集合中的路径为 $x_1 x_2 ... x_k$

那么 $res * (1-x_1) * (1-x_2)... = 100$，我们期望 res 为这个集合当中的最小值。也就意味着我们期望 $(1-x_1) * (1-x_2) ....$ 最大。

而对于 $1- x_i$ 来讲其范围是 $(0, 1]$ 中间的小数。

我们由两种证明方式可以思考：
1. 直接通过 dijkstra 贪心思路来思考。每次选取到起点乘积最大的且未被访问的点加入即可，最后得到的答案就得到了所有点到起点的最大值。
2. 通过 $log(x_1*x_2) = logx_1 + logx_2$。也就是等价于：
   $logx_1 + logx_2 + ....$ 最大值。我们知道 log(x) 是单调递增的函数，并且在 (0, 1] 时恒小于等于 0。也就是期望 $log(1/x_1) + log(1/x_2)+...$ 最小。这样我们又变回了边权非负的最短路的解决问题。

这里我们采用第一种写法来做。比较方便。


3. [AcWing 920. 最优乘车](https://www.acwing.com/problem/content/922/)

题目分析：

从顶点 1 到 s 的换乘最小代价，等价于从 1 到 s 最少经过几条路线。

对于任意一条路线上的前后两点，表示 $i$ 和 $j$ 都会经过 1 条路线。那么我们可以将路线上任意两点连接一条权值为 1 的边。时间复杂度为 $O(M*N^2)$

那么问题就变成了从 1 到 s 的最短路径和。时间复杂度为 $O(N^2)$

因此，总时间复杂度为 $O(M*N^2)$

4. [acwing 903. 昂贵的聘礼](https://www.acwing.com/problem/content/905/)

题目分析：

题目要求买到最后的聘礼。
1. 10000 金币
2. 物品 + 8000 金币

而要弄到物品则需要同样的操作：
1. 金币
2. 物品 + 金币

我们会发现：
物品与物品之间有关系，形成一张图，而权值则是对应着兑换的折扣价。

那么初始化怎么处理呢？
假设我们初始时候一个物品都没有。我们可以通过建立一个虚拟源点，指向所有的物品，边权为物品的直接购买价格。

那么问题就转换成：从虚拟源点到终点的最短路径和。

题目还有额外一个限制条件：如果物品方的地位相差超过 M，那么不能进行交易。

对于限制条件最朴素的想法就是枚举：枚举所有不超过 M 的地位范围，并且该范围一定得包含物品 1 的地位，这样才能购买到 1.


5. [acwing 3628. 边的删减](https://www.acwing.com/problem/content/3631/)

最短路树的应用

在求最短路时，所有最短路路径会形成一棵树（到同一顶点的不同最短路只取一条）。这棵树也被称为**最短路树**，该树并不唯一。

题目要求：最多保留 k 条边，能够使 **优秀点** 最多；也就是留下 **最短路树** 当中的包含顶点 1 的**连通子图**，且该子图由 k 条边，k-1 个顶点。如果 $k \geq n-1$，那么所有点都会被包含。

因此，最终的答案就是 $min(k, n-1)$


### 综合应用
综合应用指的是 **最短路算法+其他算法** 的结合应用。

1. dfs + 最短路
[acwing 1135. 新年好](https://www.acwing.com/problem/content/1137/)

题目要求求出从 1 开始遍历完成所有的 a, b, c, d, e 车站。

遍历的顺序为 $5!$ 种可能。我们距离其中的一种情况：
$1-> a -> b -> c -> d -> e$

我们要分别求出 $1->a$ 、$a->b$... 等五段路的最短路。

思路 1： 我们求出任意两点间的最短路，使用 floyd 算法，时间复杂度 $O(n^3)$，超时。

思路 2：分别以 $a,b,c,d,e$ 为起点，求出起点到任意其他点的最短距离。$O(5*x)$， $x$ 为最短路算法的时间复杂度。这里我们可以采用 spfa 或者 heap 优化的dijkstra 算法都可。

1. 预处理出 a, b, c, d, e 五个点之间的所有最短路距离。
2. 枚举所有的走法即可。


--
二分 + 最短路

2. [AcWing 340. 通信线路](https://www.acwing.com/problem/content/342/)

题意分析：
要求 1 - N 的所有路径当中第 k+1 大元素最小。而要求 **最大最小值** ，一般可以通过二分来解决。

我们二分可能的最小值，设为 x。判断是否存在一条路径，其大于 x 的边数是否大于 k：
- 如果大于 k，则 < x 的元素都不合法
- 如果小于等于 k，则 >= x 的元素都合法

而如何进行统计合法的边数呢？ 
1. 如果边的值 <= x,则权值为 0
2. 如果边的值 > x, 则权值为 1

则求 1 - n 的最短路径和即为所求的边数。在这里由于权重都为 0 或 1，我们可以采取很多种做法，比如双端队列 bfs 或者最短路算法。

双端队列 bfs 本质上是 heap 优化的 dijsktra 特例。


---
拓扑排序 + 最短路

3. [AcWing 342. 道路与航线](https://www.acwing.com/problem/content/344/)

题意分析：
1. 有 R 条双向边，边权都为非负；有 R 条单向边，边权可正可负；求起点 s 到所有顶点的最短路。顶点范围为 25000, 边数范围为 $1.5 * 10^5$.
2. 题目确保，任意航线上两点不会走回头路。也就是说，单向边不会构成环。

按照基本的题意，我们可以直接通过 spfa 算法求解，问题在于该题的测试用例经过了特殊的构造，会专门卡掉 spfa 算法，因此我们只能通过其他方式求解。

因此我们需要结合第二个题目条件求解。
1. 我们只将双向边添加到图中，形成若干个连通块。
2. 把各个连通块看成一个个点（缩点），再将单向边添加到该图中，会形成一个 DAG。再有向无环图中，无论边权为正为负，都可以按照拓扑序进行扫描，在线性时间内求出单源最短路。

详细的算法过程：
1. 将双向边加入到图中，用深度优先遍历划分图中的连通块，并且记 $c[x]$ 为顶点 x 所在的连通块编号
2. 统计每个连通块的总入度，记为 $deg[i]$
3. 建立一个队列，存储连通块编号，用于拓扑排序，最初队列中包含所有入度为 0 的连通块. 设 $d[s] = 0,$ 其他为 inf。
4. 取出队头的连通块 i，对该连通块进行 heap 优化的 dijkstra 算法：
   1. 建立一个堆，将连通块 i 中的所有结点加入到堆中
   2. 从堆中取出 $d[x]$ 最小的节点 x
   3. 如果 x 被扩展过，堆到步骤 2，否则进入下一步
   4. 扫描从 x 出发的所有边 (x, y, z) 用 $d[x] + z$ 更新 $d[y]$ 
   5. 如果 $c[x] = c[y]$,表示扩展的点仍然在连通块内，并且 $d[y]$ 被更新，则将 y 插入堆
   6. 如果 $c[x] \neq c[y]$, 则令 $deg[c[y]] -= 1$, 如果为 0，则将 $c[y]$ 插入拓扑序列的队列尾部
   7. 重复 2-6 直到堆为空
5. 重复步骤 4，直到队列为空，拓扑排序完成
   
数组 d 即为所求，那么整个时间复杂度 $O(T+P+ RlogT)$


----
反向图 + 最短路变形

4. [acwing 341. 最优贸易](https://www.acwing.com/problem/content/343/)

题目分析：
1. 如果没有进行贸易，那么可以会赚取 0 元
2. 如果进行贸易，我们假设走动的路径为 $1 -> ... -> x -> ... -> n$。那么我们一定会在路径的前面一段购买东西，后面的一段卖东西。

也就等价于：枚举路径中所有可能经过的点，设为 x。求 $1->x$ 中经过的最小值 minV，求 $x->n$ 中的最大值 maxV，然后答案等于 $max(maxV - minV)$

那么如何求权值最小的路径中的点？
1. 能否通过 dijkstra 算法解决呢？
dijkstra 算法基于贪心思想。通常维护的是路径上的 sum 问题，并且要求每条边为非负的。而本题目中维护的 max/min 性质，不具有累加性，不能保证后面的数一定比前面大（这是dijkstra 能用贪心的根本原因）。

比如如果存在 $5->6->7->5$ 这样的环，那么刚开始更新了 $dmin[5] = 10$ 而 $7->5$ 为 3，那么 $dmin[5] = 3$，而通过 dijkstra 算法是更新不了的。类似于存在负数的情况。

因此，可以通过 spfa 算法解决。

后一段我们可以通过建立一个反向图，那么 $x->n$ 也就是变成了从 $n->x$ 中的最大值了。

这样我们就得到了答案。

下面我们给出算法的具体过程：
1. 通过邻接表建立正向图 G, 每条边假设为 (i, j)，权值为边的终点值，初始化 d[s] = w[s]。那么 $s->x$ 的最小值为 $d[x]$.
   - 与此同时，建立反向图 $G'$, 每条边设为 (j, i)。权值为边的终点值，初始化 d[n] = w[n]，求 $n->x$ 的最大值为 $d'[x]$
2. 遍历所有点，求 $max(d'[x] - d[x])$ 

另外，经过实际代码发现，我们可以不用建立权值，而是直接通过 spfa 算法的思路直接求解。



解法2：
1. 预处理出 1 能够到达的所有点，存储起来，设为 back。
2. 我们将 dist[i] 全部初始化为水晶价格，并且将 back 中的点都放到 heap 当中：
   1. 用基于 heap 的dijkstra 思想求解。弹出每个元素，看 1 能够到达边的起点，如果能够到达，则更新，这样就求出所有点的最小值了
3. 最大值同步骤 2




**为什么不能通过 dp 来解决？**
因为不一定时拓扑图，状态的更新可能存在环，也就是“有后效性”，因此不能使用。

### 扩展应用
1. [AcWing 1137. 选择最佳线路](https://www.acwing.com/problem/content/1139/)

题目分析：
存在有向图，边权非负，有多个起点，从任意一个起点出发到达固定终点的最小最短路。

这种多个起点，固定终点的可以通过建立虚拟结点的方式来解决，从虚拟节点向所有的起点连接一条边权为 0 的边。这样问题又变成了单源最短路问题。

对于虚拟结点，有两种方式：
1. 真实建立虚拟结点
2. 假设已经处理了虚拟结点，然后直接进入下一步

这里我们采用第二种。

2. [AcWing 1131. 拯救大兵瑞恩](https://www.acwing.com/problem/content/1133/)
- 方法 1：状态压缩 + 动态规划 + BFS
- 方法 2：状态压缩 + 建图 + 双端 BFS + 动态规划

方法 2 代码较多，复杂，采用方案 1.

题目分析：
1。 如果没有 **钥匙和门** 的条件，题目就是简单的迷宫问题。而迷宫问题可以通过 BFS 直接求解。而加上钥匙的限制条件，就类似于 **八数码** 问题。

BFS 求解最小转移次数就是边权为 1 的最短路而已。也可以看成状态的最小转移次数。
从状态角度看，普通迷宫问题的状态就是当前坐标；八数码问题状态就是当前棋盘局面。

对于本题来讲，在同一个坐标下，有没有钥匙，属于不同的状态。因此，我们可以通过 $f[x][y][key]$ 来表示每个状态 - 表示在坐标 $(x, y)$ 持有钥匙 key 的状态。而通过二维坐标转换成一维坐标，就得到 $f[x][key]$。

那么如何表示 key 呢？ 这里我们可以利用状态压缩（钥匙种类很少），因此我们可以通过第 i 位是否为 1 来表示是否存在第 i 类钥匙。

这样我们就得到了状态表示。**题目转换成如何从 $f[1][0]$ 到 $f[n*m][...]$** 的最小步数了。我们不关心到达终点的 key 的状态，只需要最小步数到达终点就行了。

**那么状态转移是什么？**
1. 上下左右 4 个方向转移：
   - 如果有墙，不能转移
   - 如果有门，需要对应门的钥匙，可以转移
   - 其他情况，可以转移

以上转移的代价都为 1。

3. [AcWing 1134. 最短路计数](https://www.acwing.com/problem/content/1136/)

本题已经被简化：
1. 图没有方向，且没有边权，也就是相当于边权为 1
2. 存在自环和重边

因此，可以直接使用 dijkstra 算法求解，但是时间复杂度过高。

如果采用基于 heap 的 dijkstra 求解，时间复杂度满足。而由于边权都为 1。我们可以采用更简单的方式来解决，也就是 bfs 求最短路。这样只需要 $O(N+M)$ 即可。

BFS 对于每个点只会入队一次，出队一次。并且出队时候是已经保证出队节点为最短路。dijkstra 算法同样，可以抽象成拓扑结构。

但是如何权值不为 1 呢？只能使用 dijkstra 算法等最短路算法求解了。

如果权值有负数呢？只能使用 spfa 算法求解了，但由于 spfa 算法存在后效性，因此，我们需要另外一种方式：
1. 使用 spfa 算法求出最短距离
2. 建立拓扑树
3. 遍历树，用 $dist[j] == dist[t] + w[i]$ 进行更新最短路数量。



## 单源最短路题目总结：

1. 加法最小值：
   - 边长非负：dijkstra
   - 边长可负： spfa
2. 加法最大值：
   - spfa
3. 乘法最小值：
   - 边长大于等于 1： dijkstra
   - 边长大于 0: spfa
4.乘法最大值：
   - 边长 $[0, 1]$: dijkstra
   - 边长大于 0: spfa


转换成求 **最短路** 和 **最长路** 的问题。