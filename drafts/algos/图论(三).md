## 10. 拓扑排序与关键路径
1. 针对于 **有向图** 
2. 有向无环图，也叫**拓扑图**

具体算法过程(bfs):
1. 将所有入度为 0 的点入队
2. 取出队头结点，设为 t:
3. 对于 t 的所有出边，设结点 为 j，将 j 的入度减一，如果入度变为 0，则入队
4. 重复 2-3 直到队列为空。拓扑顺序就是结点出队的顺序

> 如何保证拓扑排序是字典序？

非常好解决，只需要将队列改成优先队列即可。


### 题目
1. [acwing 1191. 家谱树](https://www.acwing.com/problem/content/1193/)

题目分析：
题目要求：每个孩子比长辈后面输出，也就是相当于长辈和孩子之间有一条边，求整个图的拓扑序。




----
差分约束 求最长路 ：
1. 边权无限制 spfa O(nm)
2. 边权非负， tarjan O(n+m)
3. 边权 > 0， 拓扑排序
----

[acwing 1192. 奖金](https://www.acwing.com/problem/content/1194/)

题目分析：
都是形如 $a > b => a \geq b+1$ 的不等式，求所有变量的最小可能值。可以想到是**差分约束系统问题**。求最小值，表示我们要求 **最长路径**，也就是下界的最大值。

通常做法是：spfa 求解。本题也可以。

但是本题的边权都是正的（虚拟节点的 0 边不算），我们可以通过拓扑排序来求解。时间复杂度会更加稳定，线性解决问题。

1. 执行拓扑排序，看是否存在正环，如果存在正环，表示无解
2. 初始化， $dist[i] = 100$, 按照拓扑序依次更新 dist，得到最后的答案。


[acwing 164. 可达性统计](https://www.acwing.com/problem/content/166/)
题目分析：
1. 图是 DAG，存在拓扑序
2. 求每个点能够到达的后置节点的数量

要求 **每个节点能够到达的节点个数**，也就是求：
每个点的每条出边的对应节点能够到达点数的并集 + 自身。
对于每条出边 `(i, j)`， $f[i] = 1 + f[j_1] \cup f[j_2]...$

因为题目中存在拓扑序：因此后面的状态不会依赖前面的状态（无后效性），因此我们可以直接通过递推（dp）来依次倒序遍历拓扑序即可。

如何求并集呢？
1. 可以用 set
2. 可以用位运算

如果用位运算，因为节点的数量达到 $3*10^4$，如果直接使用整数表示的话，在某些语言中会溢出。因此可以直接使用 C++ 当中的 bitset 这样可以将时间有华为 $N*(N+M)/ 32$，需要的空间 $N^2/8$ 个字节。

在 python 中，可以直接使用位运算或者用 set 即可。


题目衍生：如果不是无环图怎么处理？

可以通过 tarjan 将图转换成无环图（强连通分量），然后按照拓扑序来求


[acwing 456. 车站分级](https://www.acwing.com/problem/content/description/458/)
题目分析：
1. 每条线路上，没有停靠的点的等级一定严格小于停靠的点。停靠的点之间关系不明确，未停靠点之间的关系也不明确。
2. 假设每个点的等级皆为变量，那么我们求这 n 个变量的值最少可以有几种

因此，我们得到一串如 $x_i > x_j => x_i \geq x_j + 1$ 的不等式。 

很容易想到 **差分约束系统**：
而答案就是 **所有点出发的最长路当中的最大值**。

如何求最长路呢？
1. 直接通过 spfa 求解
2. 由于本题题目说明，m 条路线不会产生冲突，因此图中不会存在环。也就是 DAG，并且图中的所有边都是正权，可以直接通过 **拓扑排序** 求解，递推（正序、倒序皆可）求解（dp 与 图论）

问题 1：$m, n 是 10^3 级别$。那么最坏情况下会建立 $500*500*1000 = 2.5*10^8$ 条边，邻接矩阵和邻接表都会出现内存或时间超时。

![](./images/3-8-1.png)

我们可以通过虚拟节点的方式来有效降低边的数量。左边为未停靠的点，连接一条边权为 0 的边，右边连接边权为 1 的边，那么我们的边数就变为 $O((n+m)*1000) = O(10^6)$ 级别。

算法过程：
1. 建立图
2. 拓扑排序
3. 按照正序遍历所有的点，计算最大值



### 求最长路径问题
最长路径问题是 NP 难问题。

1. 对于 DAG 图，我们可以通过拓扑排序在 $O(n+m)$ 内解决问题。
2. 一般问题，通过将边权都乘以 -1，通过 spfa 算法求最短路径长度即可。将所得到情况最后取反即可（这里无法通过 dijkstra 算法，无法处理负权问题）(有解需要不能存在正环)
3. 对于 spfa 算法，可以直接通过 $dist[j] > dist[i] + c$ 这种三角不等式直接求解最长路，无需反转边权。


## 11. 欧拉路径与欧拉回路
> 欧拉路径: 如果图 G 中的一条路径包括图中每条边恰好一次，则该路径被称为欧拉路径

> 欧拉回路：如果一个回路是欧拉路径，那么该路径被称为欧拉回路

1. 对于无向图，所有边都是连通的：
   - 存在欧拉路径的充分必要条件：度数为奇数的点为 0 个或 2 个
   - 存在欧拉回路的充分必要条件：度数为奇数的点只能为 0 个

2. 对于有向图，所有边都是连通的：
   - 存在欧拉路径的充分必要条件：要么所有点的出度等于入度；要么只有两个点的入度不等于出度，并且其中一个点的入度等于出度加一，另一个点的入度等于出度减一
   - 存在欧拉回路的充分必要条件：所有点的出度均等于入度


问题 1：如何记录欧拉回路（路径）？

hierholzers 算法和 fluery 算法

算法过程：(递归过程就是一笔画过程)
1. 选择任一顶点为起点，遍历所有邻边
2. dfs，访问相邻顶点，并将经过的边都删除
3. 如果当前顶点没有相邻边，则将顶点入栈
4. 栈中的顶点倒序输出，就是从起点出发的欧拉回路

```
# 邻接矩阵版本

dfs(cur): 
   for i in 所有顶点:
      if edge[cur][i] 存在边：
         删掉边 # 比如度数减一
         dfs(i)
   
   q.push(cur)
```
**并且得到的顶点顺序也是最小字典序**

如果要想要直接输出边：只需要将压栈动作放到 for 循环里面即可。

**为什么要删边？**

> 防止时间复杂度过高，因为是以边为标记。如果不删掉，对于某些情况，时间复杂度会达到 $O(m^2)$，比如**某个点有 m 条自环**。


### 应用
1. [acwing 1123. 铲雪车](https://www.acwing.com/problem/content/1125/)

题目分析：
1. 每条道路都是双向边
2. 起点一定能够遍历所有的边

因此我们可以得出两点：
1. 所有边是连通的
2. 所有点的入度等于出度

因此，此图中存在一条欧拉回路。能够一次性遍历所有的边。题目要求最短时间，也就是求遍历完所有边的最短时间，也就是所有边的长度即可，无需建图。

**注意四舍五入的精度问题，计算机浮点数存储的问题**

2. [acwing 1184. 欧拉回路](https://www.acwing.com/problem/content/1186/)

本题需要输出欧拉路径或回路（并且是按照边的编号输出）。由于 test case 比较多，需要做语言上的优化

3. [acwing 1124. 骑马修栅栏](https://www.acwing.com/problem/content/1126/)

4. [acwing 1185. 单词游戏](https://www.acwing.com/problem/content/1187/)

题目分析：

因为单词数量达到 $10^5$ 级别，如果根据末尾字母和每个单词的首字母相连，那么最坏情况边的数量能够达到 $10^{10}$。比如每个单词的首尾字母都相同。

那么，我们可以采用另外一种建边技巧。直接将每个单词当做一条边，顶点为首尾字母。如果使用邻接表，那么就只会有 $10^5$ 条边；如果使用邻接矩阵，那么只会有 $26*26$ 条边。

题目问是否能够将所有单词根据题目的性质排列成一行。也就是等价于：
我们是否能够从某个点出发，遍历完所有边，也就是求所建的图中是否存在欧拉路径。

本图是一个有向图，由于判断是否存在欧拉路径
1. 判断入度和出度即可，因此我们无需建立边。直接遍历即可。
2. 判断所有的边是否连通
   - 建图后，dfs，判断遍历边的数量是否和总边数相等
   - 并查集 - 看**存在边**的顶点是否在一个集合。这里虽然是有向图，但是仍然能够使用并查集，是因为我们已经在第一步判断过入度和出度了，也就意味着最多只有两个点入度和出度不等，其他所有点都是一进一出。表示能够访问对应的点，一定能够遍历完由这些点发出的边。所以能够使用并查集。