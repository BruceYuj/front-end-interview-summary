## 3. 多源汇最短路
1. floyd 算法
可以用来解决的问题有：
   1. 求多源汇最短路问题
   2. 传递闭包
   3. 找最小环
   4. 恰好经过 k 条边的最短路，倍增思想


floyd 算法又称 “插点法”，算法逻辑很简单，重要的是如何去证明它：
1. $d[i][j] = inf, d[i][i] = 0$
2. 三重循环枚举 n 个顶点，通过 $d[i][j] = min(d[i][j], d[i][k] + d[k][j])$ 进行更新


其思想是动态规划的思想。

1. 状态表示， $dp[k][i][j]$
   - 集合：所有从 i 出发，最终走到 j，且中间只经过结点编号不超过 k 的所有路径
   - 属性：路径长度的最小值
2. 状态计算：
   - 所有包含结点 k 的路径：我们通过 k 将路径 [i, j] 分成 [i, k] 和 [k, j]。两段只能含有 [1, k-1] 结点，因此：dp[k-1][i][k] + dp[k-1][k][j]
   - 所有不包含结点 k 的路径： $dp[k-1][i][j]$(只用编号为 [1, k-1] 的结点)


通过滚动数组进行优化，即得到 floyd 算法。



### 应用 1 - [acwing 1125. 牛的旅行](https://www.acwing.com/problem/content/description/1127/)

题目分析：
1. 题目说的是对称邻接矩阵，因此是无向图
2. 对于牧场的直径为牧场中任意两点最短距离的最大值。也就是说，我们需要求出所有的两点间的最短距离。
3. 只添加一条边后,假设为 (i, j)，求新生成的连通区域的最大直径。只有可能有三种情况：
   - 在原左边的连通区域中
   - 在原右边的连通区域中
   - 经过 (i, j) 的新连通区域的最短路。也就是，从 i 点出发，在左边区域中的最短路 + 从 j 点出发，在右边区域中的最短路+ dist(i, j) （证明反证法）

而节点数只有 150，因此我们得出我们的算法：
1. 通过 floyd 算法求出任意两点间的距离，设为 $dist(i, j)$
2. 枚举所有可能的连通两点的 dist，求出每个点到其他点的最短路中的最大值，记为 $d[i]$, $r1 = max(d[i])$
3. 枚举所有不连通的两点(i, j)，$r2 = min(d[i] + dist(i, j) + d[j])$
4. 答案是 $max(r1, r2)$



**传递闭包**：
从数学上讲，传递闭包是在集合 X 上求包含关系 $R$ 的最小关系传递。

从关系图上讲。如果两个点能够间接相连（存在一条路径），那么我们对这两个点进行连一条边，这叫做原图的传递闭包。

**通过传递性推导出尽量多的元素之间的关系的问题叫做传递闭包问题**，可以直接通过 floyd 算法思路直接解决，证明方式同样使用动态规划来解决。

```
for k in [1, n]:
   for i in [1, n]:
      for j in [1, n]:
         if e[i][k] and e[k][j]:
            e[i][j] = 1
```

最后得到的 $E$ 就是传递闭包的关系矩阵, 时间复杂度是 $O(n^3)$

[acwing 343. 排序](https://www.acwing.com/problem/content/345/)

题目分析：
求出所有变量的传递闭包：
1. 如果存在 $g[i][i] = 1$, 则存在矛盾
2. 如果有 $g[i][j] = g[j][i] = 0$, 表示 (i, j) 的关系无法确定
3. 存在解

算法步骤如下：
1. 遍历所有的边：
   - 每加入一条边，求一次传递闭包，并判断是否是有解或矛盾

时间复杂度为 $O(m*n^3)$

方法 2：
由于我们是动态添加边的，比如在添加边 $(i, j)$ 的时候，我们可以不用做 floyd 算法，而是直接：
1. 将和 i 有关系的点与和 j 有关系的点关联即可。
2. 将和 i 有关系的点与 j 关联；将和 j 有关系的与 i 关联

这样，我们将时间复杂度降低到 $O(m*n^2)$


[acwing 344. 观光之旅](https://www.acwing.com/problem/content/346/)

题目分析：
题目要求无向图中的最小环，并且输出对应的方案。其中点只有 $100$, 边只有 $10^4$ 级别。

在这里我们可以利用动态规划集合的思想，枚举所有的环，这里集合的划分方式和floyd的划分方式类似：以环中编号最大的结点进行划分：
1. 编号最大是 1 的环
2. ...
3. 编号最大是 n 的环

如何求编号最大是 k 的环？
我们枚举点 k 相邻的可能的点 $i, j \in [1, k)$。那么环的长度为：$d(i, j) + w(j, k) + w(k, i)$。而 $d(i, j)$ 表示最大编号不超过 k-1 的最短路径长度。而这正是 floyd 算法的中间过程。

那么我们该如何记录 path 呢？

因为 $d(i, j)$ 是由 $d(i, k_1) , d(k_1, j)$ 转移过来的，并且中间不会产生重复点（因为边权都为正，如果有重复点，那么一定有多余的环，去掉该环，距离更小），那么我们可以在转移的时候记录 $k_1$，然后递归处理 $d(i, k_1)$ 和 $d(k_1, j)$.

这样我们就求出了最小环和最小环的方案。


## 4. 差分约束
**概念**：差分约束系统是一种特殊的 **n 元一次不等式组**。包含 $n$ 个变量 $x_1, x_2, ..., x_n$ 以及 $m$ 个约束条件，每个约束条件有其中的两个变量做差构成：$x_i - x_j \leq c_k$。

求解：求一组解 $x_1 = a_1, x_2 = a_2, ... , x_n = a_n$，使得上面所有的约束条件得到满足，否则判断出无解。

$x_i - x_j \leq c_k => x_i \leq x_j + c_k$, 同**单源最短路**当中的松弛三角不等式非常类似 $dist[y] \leq dist[x] + c$。因此，我们可以将每个变量 $x$ 看作图中的一个节点，对于每个约束条件 $x_i \leq x_j + c_k$，从节点 $j$ 向节点 $i$ 连一条长度为 $c_k$ 的有向边。

我们注意到， ${a_1, a_2, a_3, ..., a_n}$ 是一组解，那么对于任意的常数 $d$，则 $a_1+d, a_2+d, ..., a_n+d$ 同样也是满足约束的一组解（做差后 d 可以直接被消掉）。

具体步骤：
1. 先将每个不等式 $x_i \leq x_j + c_k$ 转换成一条边
2. 找一个**超级源点**，使得该源点一定可以遍历到所有的边（如果一个点能够走到所有的其他点，表示该点一定能够走到所有的边，因为每个边都是由点发起的）
3. 从源点求一遍单源最短路（最长路）
   - 如果存在负环（最长路则为正环），则原不等式组一定无解
   - 如果没有负环（正环），则 $dist[i]$ 就是原不等式组的一个可行解

**如何求最大值或最小值（指每个变量的最值）？**

答：上面的分析，我们可以看出来，我们求出的变量值是相对关系的。那么为什么会出现最值呢？

这意味着一定约束中一定存在下面两种情况：
- $x_i \leq c_j , x_i \leq c_{j+1}$，这种就是求满足所有条件的最大值（上界）
- $x_i \geq c_j, x_i \geq c_{j+1}$, 这种就是求满足所有条件的最小值（下界）

问题：如何转换上面的不等式？

转换为 $x_i \leq 0 + c_j$。建立一个超级源点 0，然后建立 $0 -> i$，长度为 $c_j$ 的边即可。

举例：求 $x_i$ 的最大值。所有从 $x_i$ 出发构成的不等式为 $x_i \leq x_j + c_1 \leq x_k + c_2 + c_1 \leq .... \leq c_1 + c_2 + ... c+k$。这样会计算出一个上界。最终 $x_i$ 的最大值就是**这些上界中的最小值**。

结论：如果求 $x_i$ 的最小值，应该求最长路；如果求最大值，求最短路。

如果求最长路（其实还是求的最短路，边权都取负即可），我们可以将不等式转换成 $x_j \geq x_i + c_k$。

### 应用
1. [acwing 1169. 糖果](https://www.acwing.com/problem/content/1171/)


题目分析：
1. $x = 1$ ，则 $a = b => a \leq b , a \geq b$
2. $x = 2$, 则 $a < b => a \leq b-1$
3. $x = 3$, 则 $a \geq b$
4. $x = 4$, 则 $a > b => b \leq a-1$
5. $x = 5$, 则 $a \leq b$
6. 因为要求每个小朋友都得有糖果，那么 $a \geq 1$

题目要求我们求每个变量的最小值，因此，这里采用最长路径。


2. [acwing 362. 区间](https://www.acwing.com/problem/content/364/)

题目分析：
要想快速知道一个范围内的整数个数。可以通过 **值域的前缀和思想**来在 $O(1)$ 范围内求解。

1. $s[b] - s[b-1] \leq 1$
2. $s[b] \geq s[b-1]$
3. $s[b] - s[a-1] \geq c$

求 $s[50001]$ 的最小值。

根据条件一，我们可以知道 **点 0** 可以成为源点（其可以到达任意其他点）


解法二：
1. 贪心直接做 $O(n^2)$
2. 贪心+线段树(或者树状数组) $O(nlogn)$
   
https://www.acwing.com/solution/content/6528/


3. [acwing 1170. 排队布局](https://www.acwing.com/problem/content/1172/)

题目分析：

已知，编号的顺序就是奶牛排队的顺序。假设每头奶牛的位置为 $x_i$。那么我们会得到：
1. $x_{i+1} \geq x_i$
2. 部分 $x_j - x_i \leq L$
3. 部分 $x_j - x_i \geq D$

需要求：
1. 是否存在一组解满足上面的不等式。
2. 如果存在一组解，那么 $x_n - x_1$ 是否是无穷的
3. 否则，输出 $max(x_n - x_1)$

解决问题一，只需要转换成图，并且求图中是否存在负环即可。如果存在负环，则无解。

那么如何解决问题 2 和 3 呢？

也就是说 $x_n - x_1$ 求最大。
- 如果固定 $x_1$，则我们期望求 $x_n$ 所有上界的最小值，求最短路
- 如果固定 $x_n$，则我们期望求 $x_1$ 所有下界的最大值，求最长路

这里，我们固定 $x_1$求 $1->n$ 的最短路径。


如何寻找源点？
1. 根据条件一，我们可以知道 $n$ 是一个可以遍历所有点的点，因此可以成为源点
   - 判断负环解决，问题 1
   - 求最长路，解决问题 2
2. 我们可以建立虚拟源点，假设所有的变量都是非负的，也就是可以建立 0 到所有点的边
   - 判断负环解决，问题 1
   - 同样求最短路，解决问题 2
  
两种方式都可以。方式 2 更加简单一点。

这里，python 需要注意：如果初始化 $dist[i] = float("inf")$，那么 $float("inf") = float("inf") - 10000$ 等式仍然是成立的，因此在某些情况就不会被松弛。也就会出现判断负环出错的情况。

注意，这只会出现在我们把两个问题通过一次spfa解决。如果分为两次 spfa，则不会出现该问题。因为我们判断负环时，会初始化所有$dist[i]$ 为一个常数。

如何解决，类似于 C++ 中即可：
`INF = 0x3f3f3f3f` 即可。


4. [acwing 393. 雇佣收银员](https://www.acwing.com/problem/content/395/)

题目分析：
1. 设每个时间段的选择人员数量为 $x_i$，那么在第 i 个小时共有 $[i-7, i]$ 整个范围内上岗人数之和, 设为 s, 并且满足 $s \geq r_i$

2. 我们期望 $x_0 + x_1 + ... + x_23$ 最小

如果直接使用 $x_i$ 的来构成不等式，我们将得到多个不等式，且每个不等式中有多个变量。很难解决。

这里，我们可以通过前缀和来范围内的求和，将每个不等式的变量数降到 $\leq 2$。

由于数组是循环数组，我们需要分情况讨论：(这里由于使用前缀和，我们将下标 0 空出来，从下标 1 开始计算)
1. $x \geq 8, s[i] - s[i-8] \geq r[i] => s[i] \geq s[i-8] + r[i]$
2. $x \in [1, 7], s[i] + s[24] - s[16+i] \geq r[i] => s[i] \geq s[16+i] - s[24] + r[i]$
3. $s[i] - s[i-1] \geq 0 => s[i] \geq s[i-1]$
4. $s[i] - s[i-1] \leq nums[i] => s[i-1] \geq s[i] - nums[i]$

求 $s[24]$ 的最小值。也就是求所有下界的最大值，通过**最长路来求**.

对于**差分约束系统来讲，不等式 2 有三个变量，不符合求解**。在这里，我们的解决方案是直接从小到大枚举每一种可能的 $s[24]$ 值：
判断是否有解，如果有解，则该值就是答案

并且该值域也是满足单调性的，可以直接二分解决，降低算法常系数(注意，这里的值域为确定的人员个数，而不是数据范围，否则不满足单调性了)。


## 5. 最小生成树

1. prim 算法
算法过程如下：
1. 任取一个点为起点，设为 s，并将其加入已标记集合，设为 c。未标记点的集合设为 c1.
2. 从在 c1 中找到一个点，该点到集合 c 的距离最小，并将其加入到 c。
3. 重复步骤 2 共 n-1 次，得到了最小生成树

证明过程很简单，反证法即可：
如果步骤 2 取的最短距离两个点为 x, y。如果取得距离不是最小的（并且形成了最小生成树），那么我们在最后一定会有另外一条路径保证点 x 和 y 联通，那么这条路径和边 (x, y) 构成一条环，并且环上所有的边都大于等于 (x, y)。那么我们断开仍以一条边，那么整条环上的顶点仍然保持联通，并且不会增加最小生成树的代价。也就和我们的假设矛盾。

整个算法过程和 dijkstra 算法很像。因此，我们同样可以通过 heap 来优化整个 prim 算法，那么时间复杂度为 $O(mlogm)$，复杂度和 kruskal 算法相似，但是代码比它复杂。

4. kruskal 算法
   1. 排序所有的边
   2. 遍历所有的边:
      - 如果边上的两个顶点 x, y 如果不连通，则将该边加入到最小生成树
      - 否则，不加入

证明过程同上。

**上面的两个算法是应用在无向图当中的。**


1. 朱流算法（有向图）


> n 个点， m 条无向边，边权可正可负。求连接所有顶点的最短路径和？

上面的问题无法通过最小生成树算法来解决。



**最小生成树的理论基础**：
1. 任意一棵最小生成树，一定**可以**包含无向图中权值最小的边（可以是因为权值最小的边可能不止一个）
2. 给定一个无向图 G = (V, E), n = |V|, m = |E|。从 E 中选出 k < n-1 条边构成 G 的一个生成森林。若再从剩余的 m - k 条边中选 n-1-k 条边添加到生成森林中，使其称为 G 的生成树，并且使选出的边的权值之和最小。则该生成树一定**可以**包含 m-k 条边中连接生成森林的两个不连通结点的权值最小的边。

prim 算法和 kruskal 算法都是对定理 2 的简单应用。


### 题目应用
1. [acwing 1142. 繁忙的都市](https://www.acwing.com/problem/content/1144/)

题目分析：
1. 没有重边，无向图，要求选取一些边，将所有顶点连通起来，并且边数最少

分析得出，要让所有顶点都联通起来，至少需要 n-1 条边，也就是形成一棵树。

2. 要求该树中的权值最大值尽量的小

本身最小生成树的两个算法求的是权值之和最小的数，那么该思路是否能够求权值最大值最小的情况呢？

答：同样可以。证明和 kruskal 算法的证明一样。
1. 假设没有选择当前可选择的最小边，那么一定会选择比当前的最小边权值更大的边，并且能够和最小边形成一个环，随意断开一条边，再加上最小边，那么最终的结果一定不会比之前更大。因此就可以证明了。

2. [acwing 1143.联络员](https://www.acwing.com/problem/content/description/1145/)

本题使用了 **最小生成树** 的第二个基本定理。也就说去除一些固定的边，再剩下的边中求最小代价生成一棵树，仍然可以使用 kruskal 的算法求取。具体证明过程同上。

3. [AcWing 1144. 连接格点](https://www.acwing.com/problem/content/1146/)
本题和第二题思路是一样的，只是在预处理数据时候稍微复杂一点。
- 映射矩阵中的所有点到整数，共有 nm 个点
- 由于边长固定为 1 或 2，因此我们可以将纵向边先加入，然后再统一加入横向边

时间复杂度为 $O(nm)$，统计边的复杂度。


4. [AcWing 1146. 新的开始](https://www.acwing.com/problem/content/1148/)
题目分析：
本题是经典的虚拟源点+最小生成树的题目。虚拟源点技巧在图论中是经常被使用的技巧之一。

假设存在一个虚拟源点，其向所有矿井连一条边，边权代价为在该矿井上建立发电站的代价 $v_i$。求整个图的最小生成树。

5. [acwing 1145. 北极通讯网络](https://www.acwing.com/problem/content/1147/)

题目分析：

在基本定理当中，我们证明过最小生成树算法只做一部分，也能保证答案的正确性（贪心），无论是在任何一个部分。

存在 $n$ 个顶点，我们期望连接这 $n$ 个点， 形成一棵树。去掉树上最大的 $k-1$ 条边，保证剩下的 $n-k$ 条边中的最大值最小。也就是求加入到最小生成树当中的第 $n-k$ 条边的权值。

这里，使用 kruskal 算法（不能直接使用 prim 算法）

6. [acwing 346. 走廊泼水节](https://www.acwing.com/problem/content/348/)

题目分析：

要求我们扩展一棵树成一个完全图，保证初始的树是新生成的图的唯一最小生成树。

我们观察 kruskal 算法：
1. 排序所有的边
2. 遍历每条边 (x, y, w):
   - 如果 x 和 y 在同一集合中，跳过
   - 否则，合并，且当前边是最小生成树当中的边

在合并两个连通块时，连通块中的其他点如何处理？

设 $s_x$ 表示 $x$ 在的连通块， $s_y$ 表示 $y$ 所在的连通块。因为我们不能破坏最小生成树，因此，$s_x$ 取出一点 A 和 $s_y$ 中取出一点 B. $distance(A, B) > w$ ，也就是最小为 $w+1$。

设 $s_x$ 中有 $p$ 个点，$s_y$ 中有 $q$ 个点，那么在 kruskal 步骤 2 当中需要添加的边权之和为 $(p*q-1)*(w+1)$ 

7. [acwing 1148. 秘密的牛奶运输](https://www.acwing.com/problem/content/1150/)

题目分析：

本题求严格次小生成树。

根据定理：对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一棵最小生成树，都存在一棵（严格）最小生成树，使得这两棵树只有一条边不同。（该定理的证明也很简单，反证法即可）

我们可以枚举每一条非树边，每条非树边都会和树边形成一个环。我们只要断开环中的一条树边，就可以得到一个生成树，要使该生成树的权值之和尽量小：那么我们要断开环中较大的边。

这里要注意，因为我们要求严格次小生成树，因此要求环中树边的最大值和次大值。如果最大值和非树边相等，我们不能断开这条边，只能断开次大边。

那么该如何求任意两点的最大值和最小值呢？

我们可以在求出最小生成树之后，dfs 每个点即可，这样可以在 $O(n^2)$ 求出任意两点间的最大值和次大值。

### 次小生成树
定义：给定一个带权图 G，把图中所有的生成树按照权值从小到达排序，第二小的称为次小生成树

方法 1：先求最小生成树，在枚举删去最小生成树中的边求解。时间复杂度 $O(mlogm + nm)$

方法 2：先求最小生成树，然后依次枚举非树边，然后将该边加入到书中，同时从树中去掉一条边，使得最终的图仍然是一棵树，则一定可以求出次小生成树。

时间复杂度：$O(mlogm+n^2+(m-n))$, 如果使用**树上差分**，可以降低时间复杂度。

定理：次小生成树一定在最小生成树的邻集当中。
设 T 是图 G 的一棵生成树，对于非树边 a 和树边 b，插入边 a，删除 b，记为（+a, -b），如果操作后，仍然是一棵生成树，那么称该操作是一次可行变换。
我们称一次可行变换得到的新的生成树集合称为 T 的邻集。



## 6. 求负环
特别容易和 **01分数规划** 结合。

求负环的常用方法，一般都基于 spfa 算法。
1. 统计每个点入队的次数，如果某个点入队 n 次，则说明存在负环
2. 统计当前每个点的最短路中包含的边数，如果某个点的最短路所包含的边数大于等于 n，则也说明存在负环

对于方法 1：如何证明？
类似于 bellman ford 算法：如果循环次数达到 n 次，说明存在一条边数为 n 的最短路，而总共只有 n 个点，说明这条最短路存在相同的点，也就存在环。如果该环是正的，那么说明去掉该环会得到一个更小的最短路，和答案矛盾，因此是负环。

而对应到 spfa 算法中来，如果一个点被入队了 n 次，说明其对应的边进行了松弛了 n 次，完全等价于 bellman ford 算法的证明。 

对于方法 2： 如何证明？
对于 spfa 算法，如果每个边被松弛一次，说明该边的终点对应的最短路等于起点加一。如果该点的边数大于等于 n，则说明存在一条最短路的点个数大于 n，存在环，并且为负环。

一般推荐使用第二种方法。
方法 1 的问题：
1. 如果本身只有一个负环，那么我们需要遍历 $n(n-1) + 1 = O(n^2)$
2. 负环可能不在由起点发起的路径上
   - 对于该问题，一种做法是建立虚拟源点，然后由虚拟源点发起到所有点的边，边权为 0。求新图上的负环
     - 为什么在求负环时无需将 dist 都初始化为 正无穷 呢？因为如果存在负环，那么一定存在某些点，其 $dist[i]= -inf$。因此，在 spfa 算法中无论我们设置初始值为多少，我们一定会减少到 -inf，因此一定会超过 n 次。所以不会出现问题。

在实际的运行过程中， spfa 算法很容易接近 $O(nm)$。因此一个常用的 trick 做法时：
如果所有点的入队次数超过一个数（比如 2n） 时，我们就认为图中有很大可能是存在负环的。


**MLE 技巧优化**：
1. 在入队点数达到一定次数时，比如 2n，直接退出表示有环
2. 用 stack 替代 queue

### 题目
1. [acwing 904. 虫洞](https://www.acwing.com/problem/content/906/)

题目分析：
**求从图中的某个点出发，形成一条路径，是否能够走回到源点。并且路径和为负。** => **求图中是否存在负环** => **spfa 算法**


#### 01 分数规划
形如 $\frac{\sum f_i}{\sum t_i}$ 求最大值。一般可以通过二分求解。

我们二分值域，假设中间值为 mid.
- 如果存在一种情况使得 $\frac{\sum f_i}{\sum t_i} > mid$, 表示所有最大值一定是在 $[mid, r]$ 之间。
- 不过不存在，则答案一定在 $[l, mid]$ 范围内。


$\sum f_i > mid * \sum t_i => \sum(f_i - mid*t_i) > 0$ 也就是等价于图中是否存在正环，边权为 $f_i - mid*t_i$

求正环同样可以通过
[acwing 361. 观光奶牛](https://www.acwing.com/problem/content/363/)

题目分析：
本题可以通过 **01 分数规划**转换成求正环或负环问题。可以通过 spfa 求解。



[acwing 1165. 单词环](https://www.acwing.com/problem/content/1167/)

同样是 01 分数规划 问题，我们将值域进行二分：
求 $\sum mid - c_i < 0$，也就是求是否存在负环。

这里，如果单词与单词之间建立边，可能会达到 $O(n^2)$ 级别。如果我们直接将单词当作边，可以只需要 $O(n)$ 空间（邻接表），$O(26^4)$(邻接矩阵)


## 7. LCA 问题 - 最近公共祖先
在有根树当中，求任意两个点的最近公共祖先（为了一般化，我们将结点自己也称为它的祖先）

通常解决方法：
1. 向上标记法 - 最坏时间复杂度为 $O(n)$, n 是结点个数。具体算法：从 a 点往父节点进行遍历，并标记；从 b 点往上进行遍历，并标记；第一个重叠的结点就是答案。
2. 倍增法 - 预处理-$fa[i][j]$ 表示从 $i$ 开始，向上走 $2^j$ 步所能走到的结点。$j \in [0, logn]$. $depth[i]$ 表示深度，$depth[root] = 1$。

哨兵结点: 如果从 i 开始跳 $2^j$ 步可能会跳过根节点，那么 $f[i][j] = depth[0] = 0$


预处理 - 递推法。
- $j = 0$, $f(i, j)$ 是 i 的父节点
- $j > 0$, $f(i, j) = f(f(i, j-1), j-1)$

具体步骤：
1. bfs 预处理两个数组（预处理时间复杂度 $O(nlogn)$）
2. 先将两个点跳到同一层（2 的幂次跳）
3. 让两个点同时往上跳，一直跳到它们最近公共祖先的下一层（2 的幂次跳）
   - 为什么不直接跳到同一个结点？方便判断。因为如果跳到同一个结点，只能表明这个结点时两个点的公共祖先，不一定是最近公共祖先

查询时间复杂度 $O(logn)$

3. 离线做法 - tarjan 做法，时间复杂度 $O(n+m)$, 具体过程就是 dfs 的过程

将点分为 三大类：
- 第 0 类：还未被搜索的点，统称为第 0 类
- 第 1 类：正在搜索的分支
- 第 2 类：已经遍历过，且回溯过的点（并查集的合并在这里）

假设进行一次最近公共父节点的求解 $LCA(a, b)$，我们在搜索的过程中求解，假设 a 的类别是 1：
- 如果 b 的类别是 0，表示当前的查询还没查询到，继续搜索
- 如果 b 的类别是 1，表示当前的查询还没查询到，继续搜索，等待回溯
- 如果 b 的类别是 2，表示并查集之后的 b 的父节点就是所求的解

具体算法过程就是 dfs 的过程：

![](./images/3-6-LCA-1.png)


1. 方法 4：基于 RMQ 的做法（也可以通过线段树来做）

 dfs 的递归会带来结点被多次访问，而也就变成求区间的最值问题。

### 题目
1. [acwing 1172. 祖孙询问](https://www.acwing.com/problem/content/1174/)

题目分析：

本题的数据范围告诉我们可以通过倍增法解决。

2. [1171. 距离](https://www.acwing.com/problem/content/1173/)
根据数据范围，我们可以用 **倍增法** 求解，也可以用 **tarjan** 算法求解。

这里我们写 **tarjan**:
1. 建图
2. dfs 预处理出根节点到其他节点的最短距离（因为是一棵树，不存在环，且树边的权值为正的，那么最短路径是唯一的，$O(n)$ 可以处理结束，bfs 也可以）。任意两点间$(i, j)$的最短距离就是两点分别到最近公共祖先的最短距离之和。$d[i] + d[j] - 2* d[lca(i, j)]$, $d[i]$ 表示 $i$ 到根的最短距离。
3. 预处理所有的查询，按照类似于邻接表的方式存储
4. dfs 根节点，递归处理每个节点，假设当前正在搜索的节点为 $u$：
   -  标记 $u$ 为 1， 表示正在搜索
   -  遍历 $u$ 的邻边，邻边的点设为 $j$，如果 $j$ 的标记为 0，继续递归
      -  递归完成已 j 为根的子树后，将 j 和 u 合并，且 $p[j] = u$
   -  处理完所有的邻边后，遍历存储的所有关于 $u$ 的查询，设为 $query[u]$，如果查询的另一个点 $y$ 的标记值为 2（表示该点已经搜索结束并回溯），则$lca(u, y) = find(y)$，记录答案
   -  标记 u 为 2，表示已经回溯过


3. [acwing 356. 次小生成树](https://www.acwing.com/problem/content/description/358/)

题目分析：

本题在原有的 **次小生成树** 的数据范围扩大了点的数量，$10^5$ 级别。dfs 求任意两点间的最大值、次大值的时间复杂度是 $O(n^2)$。因此，我们需要改进:
$(i, j)$ 的最大值、次大值一定在 $(i, lca(i, j)), (lca(i, j), j)$ 的最大值和次大值里面。
因此，我们可以通过倍增的思想来改进求路径上的最值问题。将时间复杂度降低到 $O(nlogn)$

总时间复杂度 $O(mlogm+nlogn + (m-n)*logn)$

定理：对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一棵最小生成树，都存在一棵（严格）最小生成树，使得这两棵树只有一条边不同。


4. [acwing 352. 闇の連鎖](https://www.acwing.com/problem/content/description/354/)
题目分析：
1. $n-1$ 条主要边构成一棵树。我们切断任何一条主要边都会将这棵树分成两棵树
2. 每加一条附加边，都会形成一个环。环上的边有的会和其他的环重叠，有的不会

![](./images/3-6-2.png)

题目求：切一刀主要边，在切一刀附加边，形成两个不连通区域的方案数。

那么，我们来看主要边的分类情况：
1. 没有被任何环覆盖: 那么我们切完该边，就能保证形成两个不连通区域，那么我们任意切一条附加边即可
![](./images/3-6-3.png)

2. 被一个环覆盖：切完该主要边，只有切掉环中的那条附加边，才能形成不连通区域
![](./images/3-6-4.png)

3. 被两个及以上的环覆盖：且两条边后不能形成不连通区域
![](./images/3-6-5.png)

问题就变成了如何快速得知每一条主要边被环覆盖的次数了。
我们枚举每一条附加边（每条附加边都会形成一个环），形成的环即：$(i, j), (j, lca(i,j)), (lca(i, j), i)$。这个环上的每条边都需要加上 1（表示被环覆盖的次数）。

由于附加边达到 $10^5$ 级别，如果我们每次都枚举环上的所有边，最坏情况会达到 $10^10$ 级别，这是我们不想要的。

我们会发现，在环上的每条边加上同一个数，类似于**区间加数，单点查询**。在数组中，我们可以通过 **差分** 解决。这里，我们同样可以利用类似的思路 - **树上差分** 进行求解。

每遍历一条附加边 (i, j)： $d[i] += 1, d[j] += 1, d[lca(i,j)] -= 2$, 这里的 $i$ 表示 $i $ 和其父节点连接的边。

这样我们在处理完所有的附加边后，进行一次 dfs 即可求出每条主要边的被环覆盖次数, 时间复杂度为 $O(n)$

总的时间复杂度为 $O(n + nlogn + mlogn + n) => O((m+n)logn)$



## 8. 有向图的强连通分量
强连通：有向图中，如果 $i -> j$，并且 $j -> i$，表示 $(i, j)$ 两个顶点**强连通**

连通分量：如果分量中任意两个顶点都是强连通的，则该分量被称为连通分量

强连通图：图中任意两个顶点式强连通的

强连通分量(SCC: strongly connected component)：极大连通分量，如果在该分量中添加任意顶点，都会使该分量失去强连通的属性，我们称该连通分量为**强连通分量**

常用算法： **korasaju** 算法和 **tarjan** 算法

tarjan 算法是在 dfs 过程中做一些扩展操作：
![](images/3-9-1.png)

我们将图中的边分为 4 类：
1. 树枝边
2. 前向边
3. 后向边
4. 横叉边

算法思想：
对每个顶点定义两个时间戳：
- $dfn[u]$ 表示 dfs 遍历到顶点 u 的时间戳
- $low[u]$ 表示从 u 开始走，所能够遍历到的最小时间戳

强连通分量中的最高点，等价于 $dfn[u] = low[u]$

算法过程：
```
tarjan(u):
   dfn[u] = low[u] = ++ timestamp
   stk[++top] = u
   in_stk[u] = true

   for j in u 的相邻顶点:
      if dfn[jj] == 0:
         tarjan(j)
         low[u] = min(low[u], low[j])
      else if j 在 in_stack 中：
         low[u] = min(low[u], dfn[j])
      
   if dfn[u] == low[u]:
      scc_cnt++

      do {
         y = stk[top--]
         in_stk[y] = false
         id[y] = scc_cnt
      } while y != u

```

这就是整个 tarjan 算法的模板。时间复杂度 $O(n+m)$


那么求出所有的**强连通分量**有什么好处呢？

**可以将整个图通过缩点技巧变成 DAG, 这样我们可以通过拓扑排序 在线性时间求得某些属性**

缩点的思路：
```
for i in 所有顶点：
   for j in i 的所有邻点：
      if i 和 j 不在一个 SCC 中:
         加一条新边 id[i] -> id[j]
```

> 并且我们通过 tarjan 求得的所有强连通分量缩点已经是拓扑序，无需再进行一次拓扑排序。拓扑序就是逆序的缩点编号。

### 题目
1. [acwing 1174. 受欢迎的牛](https://www.acwing.com/problem/content/1176/)

题目分析：
如果 A 认为 B 受欢迎，表示一种关系，并且关系具有 **传递性**。求哪些牛被其他牛都欢迎。
1. 如果我们建立 $A->B$。我们需要枚举所有的点，然后判断其他点是否能够到达该点。时间复杂度过高

2. 如果我们建立反边， $B->A$。那么我们枚举所有的点，然后判断该点是否能够到达其他的点，只需要 $O(n(n+m))$，时间复杂度有降低，但是仍然太高。

因为 **强连通分量** 中任意两点是强连通的，变换到本题中，强连通分量中任意两个顶点互相受欢迎，以 $A->B$ 建边为例，我们将图的所有强连通分量缩点并形成 DAG 图。

如果 DAG 图中只有一个顶点的出度为 0，则该顶点代表的强连通分量中所有点即为所求。

如果反向建边的话，则是 DAG 图中只有一定顶点的入度为 0，则表示该顶点代表的强连通分量即为所求，和正向建边是对称的。

时间复杂度 $O(n+m)$

2. [acwing 367. 学校网络](https://www.acwing.com/problem/content/369/)

题目分析：

已知学校之间的关系构成一个有向图，顶点是学校。
- 问 1： 最少从几个顶点出发可以遍历完所有的顶点？
- 问 2: 最少需要添加几条边，可以让图变成一个**强连通有向图**？

对于问题 1，朴素想法是枚举所有起点的组合，判断是否能够通过这些起点遍历完所有顶点，枚举起点就达到 $2^n$ 级别，不符合要求。

我们需要挖掘图论中的性质：

有向图的**强连通分量** 中的任意两点是连通的，也就是说从任意点出发都能遍历完整个分量。

因此，我们可以将整个图划分成一个个强连通分量，并且缩点，就形成了 DAG 图。而问题 1 的答案就是入度为 0 的缩点数量。

问题 2 该如何解决？

首先答案是 $max(p, q)$, $p$ 是入度为 0 的缩点数量， $q$ 是出度为 0 的缩点数量。

该如何证明？
1. 先证明 $p \leq q$ 的情况，$q \leq p$ 对称证明即可。

- $p = 1$ 时，表示起点能够走到其他所有的顶点。我们把起点和终点之间的点都缩成一个点。要想整个图变成强连通的，只需要每个终点连一条有向边指向起点即可。答案就是 $q$。

- $p \geq 2, q \geq p$ 时，此时至少存在 2 个起点，设为 p1, p2; 两个终点 q1, q2，满足从 p1 走到 q1, p2 走到 q2。

证明，反证法。如果不存在两个起点能够走到不同的终点，那么表示所有起点都只能走到一个终点，与定义矛盾。

我们可以从 q1 向 p2 连一条新边，那么起点和终点各自减一。以这种方式，我们可以构造 $p-1$ 条边。剩下 1 个起点 $q - p + 1$ 个终点，我们只需要按照第一种情况构造 $q-p+1$ 条边即可，即总共 $q$ 条边。

因此，答案就是 $max(p, q)$



算法过程：
1. tarjan 算法求出所有的强连通分量
2. 遍历所有的边，计算两端顶点的所代表连通分量的入度和出度

[acwing 1175. 最大半连通子图](https://www.acwing.com/problem/content/1177/)

题目分析：

> 半连通图：只对于图中的任意两个顶点$u, v$，存在一条从 $u -> v$ 或者从 $v->u$ 的路径，我们就称该图是半连通的

> 导出子图：对于 $G' = (V', E'), V' \in V, E'$ 是 $E$ 中所有和 $V'$ 相关的边，我们称 $G'$ 是 $G$ 的导出子图

> 最大半连通子图：所有半连通子图中节点数最多的

首先每个强连通分量一定是半连通子图。这样我们通过分析完图中所有的强连通分量后，可以缩点形成一个 DAG.

答案就是从 DAG 中起点到终点的所有路径中，节点数量之和最多的路径。

由于 DAG 图的特殊性，我们可以通过递推求解（dp）。
求数量也和背包问题求方案数类似。

这里需要注意的是，缩点后新图两点之间可能有重边。这里我们需要去除掉，不然影响递推结果。如何去重边？通过 hash table 就好。

算法过程：
1. tarjan 求出所有的强连通分量，并缩点编号，和记录每个强连通分量的节点个数
2. 将所有缩点建立新的边，并去重边
3. 按照拓扑序递推答案


[acwing 368. 银河](https://www.acwing.com/problem/content/370/)

题目分析：
本题是求 N 个变量之和的最小值，且 N 个变量满足下面的关系：
1. $T = 1,  a = b => a \geq b, b \geq a$
2. $T = 2, a < b => b \geq a+1$
3. $T = 3, a \geq b$
4. $T = 4, a > b => a \geq b+1$
5. $T = 5, a \leq b  => b \geq a$
6. $a \geq 1$

相当于是多个不等式，并且每个不等式最多只有两个变量。我们很容易和 **差分约束系统** 对上。由于本题求最小值，也就是多个下界的最大值，要用最长路求解。

源点该如何找？

根据条件 6，我们会发现 0 点会连接所有的其他点，因此可以做源点。

求最长路，我们通常用 spfa 来做。最好复杂度 $O(m)$ 即可，但是复杂度并不稳定。

这里我们用一种更加稳定的做法，仔细观察会发现，每条边的路径长度是非负的。

我们通过 tarjan 求出当前图中的所有强连通分量，缩点形成 DAG。

如果存在一个强连通分量，其中它的边权大于 0，那么表示一定会存在正环，无解。

否则，对 DAG 进行递推求解最长路（边权非负）。


## 9. 无向图的双连通分量
双连通分量：分为点双连通分量和边双连通分量。

点双连通图：如果一个无向图中去掉任意一个节点都不会改变此图的连通性，即不存在割点，则被称为点双连通图

边双连通图：如果一个无向图中去掉任意一条边都不会改变此图的连通性，即不存在桥，则被称为边双连通图。

点（边）双连通分量(V-DCC / E-DCC)：一个无向图中的每一个极大点（边）双连通子图。

> 两个割点之间的边不一定是桥

> 任何桥之间的两个点不一定是割点


通用算法：tarjan 算法

1. 求边的双连通分量 -> 引入时间戳

类似于有向图的强连通分量，但是无向图不存在横叉边（因为方向是双向的）。

问题 1： 如何找到桥？

如果对于一条边 $(x, y)$，$y$ 能够走到 $x$ 或者 $x$ 的祖先节点，表示这条边不是桥

也就是桥: `dfn[x] < low[y]`

问题 2：如何找所有边的双连通分量？
   - (1). 可以删掉所有桥，剩下的连通分量即为所求
   - (2). 用 stack 辅助，也就是 `dfn[x] == low[x]`时，那么 $x$ 的父节点形成的边就是桥，且 $x$ 就是对应的边双连通分量的最上面的点



## 10. 二分图
> 二分图： 如果一张无向图的 $N(N\geq 2)$ 个顶点可以分成 $A, B$ 两个集合， $A \cap B = \phi$, 并且在同一个集合内的点都没有边相连，我们称这张图为二分图，且 $A, B$ 被称为二分图的左部和右部。

二分图的判定：一张无向图是二分图，当且仅当图中不存在奇数环（长度为奇数的环）。也就是染色法过程中不存在矛盾。


**匈牙利算法：最坏时间复杂度 $O(nm)$**

> 匹配：一组匹配指的是图中的边的集合，集合中任意两条边都没有公共端点。匹配中包含边数最多的被称为**最大匹配**。

> 匹配边：对于一组匹配 $S$，属于 $S$ 的边被称为 **匹配边**，不属于 $S
$ 的边被称为非匹配边。匹配边的两个端点被成为 **匹配点**，其他节点被称为 **非匹配点**。

> 增广路径：如果二分图中存在一条连接两个非匹配点的路径，并且使得非匹配边和匹配边交替出现，那么我们称该路径是当前匹配的增广路。

增广路的性质：
1. 长度是奇数
2. 路径上 1, 3, 5, ..., len 是非匹配边，偶数边是匹配边。

根据上面的性质，我们将路径上的边状态取反，使得匹配边变成非匹配边，非匹配边变成匹配边，得到的新的 $S'$ 仍然是一组匹配，并且匹配的边数加 1。

> **二分图的一组匹配 S 是最大匹配，当且仅当图中不存在 S 的增广路**

匈牙利算法的主要过程（计算二分图的最大匹配）：
1. 设 $S = \phi$, 即所有边都是非匹配边
2. 寻找增广路，将路径上的所有边状态取反，得到更大的匹配
3. 重复步骤 2，直到不存在增广路

步骤 2：

算法依次尝试给每个左部结点 $x$ 寻找一个匹配的右部结点 $y$。y 能和 x 匹配，需要满足下面两个条件之一：
1. y 本身是非匹配点。此时无向边 $(x, y)$ 本身就是非匹配边，自己构成一条长度为 1 的增广路
2. y 已经与某个左部点 $x'$ 匹配，但是能够从 $x'$ 出发找到另一个右部点 y'（可以是匹配点，也可以是非匹配点，只要 (x',y') 是非匹配边，并且最后的路径端点是非匹配点即可），那么 $x->y->x'->y’....$ 是一条增广路。

匈牙利算法的正确性基于贪心策略：
1. 当一个节点成为匹配点后，最多因为找到增广路而更换匹配对象，但是绝对不会再变为非匹配点。（因为变为非匹配点并不会对最后的答案有作用，所以不需要边）

```python
def dfs(x):
   for y in x 的所有邻边的端点：
      if not vis[y]:
         vis[y] = True

         if not match[y] or dfs(match[y]):
            match[y] = x
            return True
      
   return False

for i in range(1, n+1):
   vis = [False] * (n+1)
   if dfs(i):
      ans += 1

```


### 最小点覆盖
> 对于图 G, 找出一个最小的点集 S, 使得图中任意一条边都有至少一个点属于 S, 这个点集被称为最小点覆盖

> 在二分图当中，最小点覆盖的点数等于二分图最大匹配的边数

证明：
1. 最小点覆盖一定大于等于最大匹配边数。因为匹配的每条边都至少得取一个。
2. 最小点覆盖一定小于所有的可能点覆盖。因此只要证明如果对于任意二分图，我们能够构造一组点覆盖，使包含的点数等于最大匹配包含的边数即可。

构造方式如下：
1. 求出最大匹配
2. 从左部每个非匹配点出发（这些起点也要标记），再执行一次 dfs 寻找增广路的过程（一定会失败），标记访问过的结点
3. 取**左部未被标记的点（这些点都是匹配点），右部被标记的点（这些点都是匹配点）**。这些点构成该二分图的最小点覆盖。这些点恰好是每条匹配边都去了一个点。

证明如下：
1. 左部非匹配点一定会被标记 - 因为是出发点
2. 右部非匹配点一定都没有被标记 - 否则就相当于找到了增广路
3. 一对匹配点，要么都被标记，要么都没有被标记 - 因为在寻找增广路的过程中，左部的匹配点只能够通过右部到达

如何证明这种构造能够覆盖所有的边？

1. 左部非匹配点 - 右部匹配点形成的边: 被覆盖到，因为右部匹配点都被标记，并被加入到了构造中
2. 左部非匹配点 - 右部非匹配点：一定不会有边，因为如果有边，就相当于存在一条增广路，与最大匹配不符
3. 左部匹配点 - 右部匹配点：
   - 左部匹配点中被标记的：因为是由右部匹配点到达的，因此该边被覆盖到
   - 左部匹配点中没有被标记的：已经加入到构造中，所以被覆盖到
4. 左部匹配点 - 右部非匹配点：
   - 左部匹配点中被标记的：如果存在边，一定存在一个增广路，所以没有边
   - 左部匹配点中没有被标记的：已经加入到构造中，所以被覆盖到

所以我们就证明了我们的构造能够形成一个**覆盖点集**。

> 独立集：给定一张无向图 G = (V, E)，满足下面条件的点集 S 被称为图的独立集：
   - $S \in V$
   - 对于 S 中的任意两个点，不存在连边

> 最大独立集：包含点数最多的独立集

> 无向图的团：图的子图，并且子图中的任意两点之间都有一条边相连。点数最多的团被称为图的最大团。

> 补图：已知图 G = (V, E)。G' = (V, E') $E' = {(x, y) \notin E}$

> 定理：无向图的最大团等于其补图的最大独立集

> 对于一般无向图，最大团、最大独立集问题是 NPC 问题

> 定理：设 G 是有 n 个结点的二分图，G 的最大独立集的大小等于 $n-最大匹配数$

证明如下：
选出最多的点构成最大独立集 <=> 在图中去掉最少的点后，使得剩下的点之间没有边 <=> 用最少的点覆盖所有的边


**有向无环图的最小路径点覆盖问题**

给定一张有向无环图，要求用尽量少的不相交的简单路径，覆盖有向无环图的所有顶点（相当于每个顶点恰好被覆盖一次）。这个问题被称为 DAG 图的最小路径点覆盖问题。

构造：
设原有的 DAG 图为 $G = (V, E), n =|V|$。将 G 中的每个点 x 拆分成 x 和 x+n 两个点。建立一张新的二分图，$[1, n]$ 属于左部, $[n+1, 2n]$ 属于右部，对于原图上的每条边 $(x, y)$，连接一条 $(x, y+n)$ 的边。最终的二分图称为 G 的拆点二分图，记为 $G_2$。

> 定理：DAG 的最小路径点覆盖包含的路径条数，等于总点数 $n$ 减去二分图 $G_2$ 的最大匹配数

证明：

**证明可以去除孤立点，或者将孤立点当做自己指向自己的一条路径。**


在 DAG 的最小路径点覆盖当中，对于任意的点 x，因为路径不相交，所以 x 的入度和出度都不超过 1。除了孤立点，其他点被覆盖，所以入度和出度最少有一个是 1。

因此，最小路径覆盖中的所有边，在拆点二分图中构成一组匹配。并且其中的每条边 $(x, y)$ 的起点和二分图每条匹配边 $(x, y+n)$ 的左部点 x 是一一对应的。

而只有每条路径的终点没有出边，所以在拆点二分图中会匹配失败。即拆点二分图的左部非匹配点和路径终点是一一对应的。

最小路径覆盖 <=> 路径的终点数最少 <=> 左部非匹配点最少 <=> 总点数 - 最大匹配数


> $$最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 - 最小路径覆盖$$


**最小路径可重复点覆盖：**

在一张 DAG 图中，要求用尽量少的可相交的简单路径，覆盖 DAG 的所有顶点（相当于一个节点可以被覆盖多次），这个问题被称为有向无环图的最小路径可重复点覆盖问题。

其等价于先对有向图传递闭包，得到有向无环图 G',再在 G' 上求一般的最小路径点覆盖问题。

证明：任意有路径相交的点覆盖一定可以通过传递闭包变成没有路径相交的点覆盖问题。



1. 最优匹配 - KM

2. 多重匹配




