## 基本概念
1. 拓扑排序

拓扑排序对应着 DAG 图，也就是有向无环图。目的是将图中的所有顶点排成线性序列，使得途中任意一对顶点 $u$ 和 $v$, 如果 $<u, v> \in E$，则 u 在线性序列中必须出现在 v 之前。

扩展：
1. 只有 DAG 图才会有拓扑序
2. 对于一个 DAG，可能存在多个拓扑序

算法过程：
1. 建立图，统计每个顶点 v 的入度，将入度为 0 的所有元素入队
2. 循环取出对头元素，假设为 t
   - 将 t 发出的所有边对应的顶点入度减 1，如果当前顶点入度被减为 0，则将该顶点入队
3. 则出队的顺序就是拓扑排序。如果出队元素个数小于顶点个数，则表示图中有环，不存在拓扑序。

[acwing 848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)


## 单源最短路
1. 边权非负
   - 朴素 dijkstra，时间复杂度 $O(n^2)$
   - 堆优化的 dijkstra, 时间复杂度 $O(mlogm)$
2. 有负权边
   - bellman-ford: $O(nm)$
   - spfa: 平均 $O(m)$, 最坏 $O(nm)$

基础算法理解并不难，题目的难点在于如何将问题转化和抽象成对应的算法模型。

dijkstra 算法的基础核心是贪心，需要确保每个边权都是正的。

下面我们来看下具体的算法：
1. 假设 $d[i]$ 表示源点 1 到 i 的最短距离，初始化为无穷大。则 $d[1] = 0$，$vis$ 数组表示当前顶点是否已经被访问过。
2. 循环 n 次，在每次循环中：
   1. 查找未被访问的顶点中 $d[i]$ 最小的顶点，设为 t。则 $d[t]$ 此时的值即为$1 -> t$ 的最短距离。我们将 $vis[t]$ 标记为 true。
   2. 将 t 关联的边用三角不等式进行更新

为什么需要边权都是正的？

> 确保 dijkstra 算法贪心的正确性。按照 dijkstra 算法只要某个顶点被访问过，则该点到源点的最短距离就确定了。

[acwing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

我们仔细观察会发现，只有在第二步通过 **三角不等式** 进行松弛的时候才会更新 dist 数组。也就是说，只有松弛操作才会影响到最短距离。

因此，我们可以通过最小堆来维护所有的被更新的 $dist[i]$ 这样可以在 $O(1)$ 来获取此时最小的 $dist[i]$。总共更新次数最多是 $m$ 次，而在二叉堆中维护数据的成本是 $O(logn)$，因此松弛操作的复杂度为 $O(mlogm)$。

另外，找到当前没有标记且离源点最近的点的复杂度总共 n 次。因此时间复杂度由最大的决定，总共为 $O(mlogm)$

算法思路为：
1. 最小堆为 q，设 dist 维护 1 到 所有点的最短距离。$dist[1] = 0$,并将 $(dist[1], 1)$ 放入到 q 中。标记数组为 vis。
2. 弹出堆顶元素，设为 t：
   - 如果 t 已经被标记 ，continue
   - 标记 t，并且将 t 关联的所有顶点用三角不等式更新。如果有更新，对应的顶点放入到 q 中




### bellman ford
动态规划思想

bellman ford 算法思想很简洁。其本质是：在第 k 次循环中，所有源点到顶点的最短路径边长数 小于等于 k 的dist都会被更新完成。难点在于如何理解算法的正确性。

在 **算法导论** 当中，是通过数学归纳法来证明的，用到 松弛的收敛定理。

算法过程如下：
1. 循环 n-1 次
2. 每次循环当中，对 m 条边进行松弛操作

因此，时间复杂度为 $O(nm)$。

其可以用来判断是否存在负环：如果在第 n 次循环当中，仍然存在边可以进行松弛操作，那么一定存在负环。

因为进行 n 次循环后，可以找到一条最短路，路径上存在 n+1 个点，根据容斥原理，一定存在一个环，并且这个环减少了路径和，因此是负环。

[AcWing 853. 有边数限制的最短路 ](https://www.acwing.com/activity/content/problem/content/922/1/)
1. 进行 k 次循环，每次循环松弛所有的边。一定可以得出由源点出发经过 k 条边到达对应顶点的当前最短路径和。

避免同层循环互相影响，因此我们需要将 dist 数组进行复制处理。


### spfa 算法
spfa 是国内的叫法，在国际上，该算法被称为基于队列优化的 bellman ford 算法。

其思想是只有被三角不等式进行松弛的顶点才有可能影响到其它顶点。所以我们通过队列维护被更新过的顶点，每次只需要处理这些顶点即可。这样避免每次重复遍历未松弛的边。

其算法步骤为：
1. 设队列为 q，将源点 s入队，`vis[s]` 标记为 true
2. 弹出队头元素，设为 t:
   - `vis[t]` 设为 false，表示队列中没有 t 了
   - 处理 t 发起的每条边，如果某个顶点能够通过三角不等式进行松弛，设为 i，则将 i 放入到队列中，并标记 i
3. 循环进行步骤 2，直到队列为空

值得注意的是，spfa 算法可能会被通过数据构造卡掉。


> 我们可以通过 spfa 算法来判断是否存在负环。

常用方法：
1. 统计每个点的入队次数，如果某个点入队次数到达 n 次，则说明存在负环（没理解）
2. 统计每个点的最大短路中所包含的边数，如果某个点的最短路所包含的边数大于等于 n，也就是表明这条路径存在 n+1 个点，也就是表明存在环。如果该环是正的，那么我们可以去掉该环，得到一个更小的最短路，因此该环一定是负的。

朴素做法是：对于每个点进行一次 spfa，那么平均时间复杂度将达到 $O(nm)$，乘上常系数很容易超时。

更好的做法是，我们可以在原图的基础上增加一个虚拟源点，这样就将多源汇最短路转换成单源最短路问题。从虚拟源点向其他所有点建立一条边权为 0 的边，那么原图有负环等价于新图有环。


## 多源汇最短路
1. floyd 算法
可以用来解决的问题有：
   1. 求多源汇最短路问题
   2. 传递闭包
   3. 找最小环
   4. 恰好经过 k 条边的最短路，倍增思想


floyd 算法又称 “插点法”，算法逻辑很简单，重要的是如何去证明它：
1. $d[i][j] = inf, d[i][i] = 0$
2. 三重循环枚举 n 个顶点，通过 $d[i][j] = min(d[i][j], d[i][k] + d[k][j])$ 进行更新


其思想是动态规划的思想。

1. 状态表示， $dp[k][i][j]$
   - 集合：所有从 i 出发，最终走到 j，且中间只经过结点编号不超过 k 的所有路径
   - 属性：路径长度的最小值
2. 状态计算：
   - 所有包含结点 k 的路径：我们通过 k 将路径 [i, j] 分成 [i, k] 和 [k, j]。两段只能含有 [1, k-1] 结点，因此：dp[k-1][i][k] + dp[k-1][k][j]
   - 所有不包含结点 k 的路径： $dp[k-1][i][j]$(只用编号为 [1, k-1] 的结点)


通过滚动数组进行优化，即得到 floyd 算法。




传递闭包：
如果两个点能够间接相连，那么我们对这两个点进行连一条边，这叫做原图的传递闭包。

可以直接通过 floyd 算法思路直接解决，证明方式同样使用动态规划来解决。



## 差分约束


## 最小生成树

## 二分图



dp 一般可以转化为 拓扑序上的最短路问题。

