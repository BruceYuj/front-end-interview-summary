## 基本概念
1. 拓扑排序

拓扑排序对应着 DAG 图，也就是有向无环图。目的是将图中的所有顶点排成线性序列，使得途中任意一对顶点 $u$ 和 $v$, 如果 $<u, v> \in E$，则 u 在线性序列中必须出现在 v 之前。

扩展：
1. 只有 DAG 图才会有拓扑序
2. 对于一个 DAG，可能存在多个拓扑序

算法过程：
1. 建立图，统计每个顶点 v 的入度，将入度为 0 的所有元素入队
2. 循环取出对头元素，假设为 t
   - 将 t 发出的所有边对应的顶点入度减 1，如果当前顶点入度被减为 0，则将该顶点入队
3. 则出队的顺序就是拓扑排序。如果出队元素个数小于顶点个数，则表示图中有环，不存在拓扑序。

[acwing 848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)


## 单源最短路
1. 边权非负
   - 朴素 dijkstra，时间复杂度 $O(n^2)$
   - 堆优化的 dijkstra, 时间复杂度 $O(mlogm)$
2. 有负权边
   - bellman-ford: $O(nm)$
   - spfa: 平均 $O(m)$, 最坏 $O(nm)$

基础算法理解并不难，题目的难点在于如何将问题转化和抽象成对应的算法模型。

dijkstra 算法的基础核心是贪心，需要确保每个边权都是正的。

下面我们来看下具体的算法：
1. 假设 $d[i]$ 表示源点 1 到 i 的最短距离，初始化为无穷大。则 $d[1] = 0$，$vis$ 数组表示当前顶点是否已经被访问过。
2. 循环 n 次，在每次循环中：
   1. 查找未被访问的顶点中 $d[i]$ 最小的顶点，设为 t。则 $d[t]$ 此时的值即为$1 -> t$ 的最短距离。我们将 $vis[t]$ 标记为 true。
   2. 将 t 关联的边用三角不等式进行更新

为什么需要边权都是正的？

> 确保 dijkstra 算法贪心的正确性。按照 dijkstra 算法只要某个顶点被访问过，则该点到源点的最短距离就确定了。

[acwing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

我们仔细观察会发现，只有在第二步通过 **三角不等式** 进行松弛的时候才会更新 dist 数组。也就是说，只有松弛操作才会影响到最短距离。

因此，我们可以通过最小堆来维护所有的被更新的 $dist[i]$ 这样可以在 $O(1)$ 来获取此时最小的 $dist[i]$。总共更新次数最多是 $m$ 次，而在二叉堆中维护数据的成本是 $O(logn)$，因此松弛操作的复杂度为 $O(mlogm)$。

另外，找到当前没有标记且离源点最近的点的复杂度总共 n 次。因此时间复杂度由最大的决定，总共为 $O(mlogm)$

算法思路为：
1. 最小堆为 q，设 dist 维护 1 到 所有点的最短距离。$dist[1] = 0$,并将 $(dist[1], 1)$ 放入到 q 中。标记数组为 vis。
2. 弹出堆顶元素，设为 t：
   - 如果 t 已经被标记 ，continue
   - 标记 t，并且将 t 关联的所有顶点用三角不等式更新。如果有更新，对应的顶点放入到 q 中




### bellman ford
动态规划思想

bellman ford 算法思想很简洁。其本质是：在第 k 次循环中，所有源点到顶点的最短路径边长数 小于等于 k 的dist都会被更新完成。难点在于如何理解算法的正确性。

在 **算法导论** 当中，是通过数学归纳法来证明的，用到 松弛的收敛定理。

算法过程如下：
1. 循环 n-1 次
2. 每次循环当中，对 m 条边进行松弛操作

因此，时间复杂度为 $O(nm)$。

其可以用来判断是否存在负环：如果在第 n 次循环当中，仍然存在边可以进行松弛操作，那么一定存在负环。

因为进行 n 次循环后，可以找到一条最短路，路径上存在 n+1 个点，根据容斥原理，一定存在一个环，并且这个环减少了路径和，因此是负环。

[AcWing 853. 有边数限制的最短路 ](https://www.acwing.com/activity/content/problem/content/922/1/)
1. 进行 k 次循环，每次循环松弛所有的边。一定可以得出由源点出发经过 k 条边到达对应顶点的当前最短路径和。

避免同层循环互相影响，因此我们需要将 dist 数组进行复制处理。


### spfa 算法
spfa 是国内的叫法，在国际上，该算法被称为基于队列优化的 bellman ford 算法。

其思想是只有被三角不等式进行松弛的顶点才有可能影响到其它顶点。所以我们通过队列维护被更新过的顶点，每次只需要处理这些顶点即可。这样避免每次重复遍历未松弛的边。

其算法步骤为：
1. 设队列为 q，将源点 s入队，`vis[s]` 标记为 true
2. 弹出队头元素，设为 t:
   - `vis[t]` 设为 false，表示队列中没有 t 了
   - 处理 t 发起的每条边，如果某个顶点能够通过三角不等式进行松弛，设为 i，则将 i 放入到队列中，并标记 i
3. 循环进行步骤 2，直到队列为空

值得注意的是，spfa 算法可能会被通过数据构造卡掉。


> 我们可以通过 spfa 算法来判断是否存在负环。

常用方法：
1. 统计每个点的入队次数，如果某个点入队次数到达 n 次，则说明存在负环（没理解）
2. 统计每个点的最大短路中所包含的边数，如果某个点的最短路所包含的边数大于等于 n，也就是表明这条路径存在 n+1 个点，也就是表明存在环。如果该环是正的，那么我们可以去掉该环，得到一个更小的最短路，因此该环一定是负的。

朴素做法是：对于每个点进行一次 spfa，那么平均时间复杂度将达到 $O(nm)$，乘上常系数很容易超时。

更好的做法是，我们可以在原图的基础上增加一个虚拟源点，这样就将多源汇最短路转换成单源最短路问题。从虚拟源点向其他所有点建立一条边权为 0 的边，那么原图有负环等价于新图有环。


### 题目应用
1. [acwing 1127. 香甜的黄油](https://www.acwing.com/problem/content/1129/)

题目解析：
有 n 个点，m 条边。每个点可能有 $x \in [0, k]$ 个物品。选择任意一个点作为终点，那么将所有物品传递到该终点的最小代价和。

n 的范围是 800， m 的范围是 1450。

这里我们直接用朴素的想法即可。
1. 枚举所有的点，设为 i
2. 以 i 为起点，计算该点到其他点的最短距离。然后计算代价和
3. 答案即为所有代价和的最小值。

具体计算最短距离的算法我们可以采用：堆优化的 dijkstra 或者 spfa 都可。


2. [AcWing 1126. 最小花费](https://www.acwing.com/problem/content/1128/)
题目分析：

假设由 A 到 B 的路径构成一个集合。每个集合中的路径为 $x_1 x_2 ... x_k$

那么 $res * (1-x_1) * (1-x_2)... = 100$，我们期望 res 为这个集合当中的最小值。也就意味着我们期望 $(1-x_1) * (1-x_2) ....$ 最大。

而对于 $1- x_i$ 来讲其范围是 $(0, 1]$ 中间的小数。

我们由两种证明方式可以思考：
1. 直接通过 dijkstra 贪心思路来思考。每次选取到起点乘积最大的且未被访问的点加入即可，最后得到的答案就得到了所有点到起点的最大值。
2. 通过 $log(x_1*x_2) = logx_1 + logx_2$。也就是等价于：
   $logx_1 + logx_2 + ....$ 最大值。我们知道 log(x) 是单调递增的函数，并且在 (0, 1] 时恒小于等于 0。也就是期望 $log(1/x_1) + log(1/x_2)+...$ 最小。这样我们又变回了边权非负的最短路的解决问题。

这里我们采用第一种写法来做。比较方便。


3. [AcWing 920. 最优乘车](https://www.acwing.com/problem/content/922/)

题目分析：

从顶点 1 到 s 的换乘最小代价，等价于从 1 到 s 最少经过几条路线。

对于任意一条路线上的前后两点，表示 $i$ 和 $j$ 都会经过 1 条路线。那么我们可以将路线上任意两点连接一条权值为 1 的边。时间复杂度为 $O(M*N^2)$

那么问题就变成了从 1 到 s 的最短路径和。时间复杂度为 $O(N^2)$

因此，总时间复杂度为 $O(M*N^2)$

4. [acwing 903. 昂贵的聘礼](https://www.acwing.com/problem/content/905/)

题目分析：

题目要求买到最后的聘礼。
1. 10000 金币
2. 物品 + 8000 金币

而要弄到物品则需要同样的操作：
1. 金币
2. 物品 + 金币

我们会发现：
物品与物品之间有关系，形成一张图，而权值则是对应着兑换的折扣价。

那么初始化怎么处理呢？
假设我们初始时候一个物品都没有。我们可以通过建立一个虚拟源点，指向所有的物品，边权为物品的直接购买价格。

那么问题就转换成：从虚拟源点到终点的最短路径和。

题目还有额外一个限制条件：如果物品方的地位相差超过 M，那么不能进行交易。

对于限制条件最朴素的想法就是枚举：枚举所有不超过 M 的地位范围，并且该范围一定得包含物品 1 的地位，这样才能购买到 1.


### 综合应用
综合应用指的是 **最短路算法+其他算法** 的结合应用。

1. dfs + 最短路
[acwing 1135. 新年好](https://www.acwing.com/problem/content/1137/)

题目要求求出从 1 开始遍历完成所有的 a, b, c, d, e 车站。

遍历的顺序为 $5!$ 种可能。我们距离其中的一种情况：
$1-> a -> b -> c -> d -> e$

我们要分别求出 $1->a$ 、$a->b$... 等五段路的最短路。

思路 1： 我们求出任意两点间的最短路，使用 floyd 算法，时间复杂度 $O(n^3)$，超时。

思路 2：分别以 $a,b,c,d,e$ 为起点，求出起点到任意其他点的最短距离。$O(5*x)$， $x$ 为最短路算法的时间复杂度。这里我们可以采用 spfa 或者 heap 优化的dijkstra 算法都可。

1. 预处理出 a, b, c, d, e 五个点之间的所有最短路距离。
2. 枚举所有的走法即可。


--

2. [AcWing 340. 通信线路](https://www.acwing.com/problem/content/342/)

题意分析：
要求 1 - N 的所有路径当中第 k+1 大元素最小。而要求 **最大最小值** ，一般可以通过二分来解决。

我们二分可能的最小值，设为 x。判断是否存在一条路径，其大于 x 的边数是否大于 k：
- 如果大于 k，则 < x 的元素都不合法
- 如果小于等于 k，则 >= x 的元素都合法

而如何进行统计合法的边数呢？ 
1. 如果边的值 <= x,则权值为 0
2. 如果边的值 > x, 则权值为 1

则求 1 - n 的最短路径和即为所求的边数。在这里由于权重都为 0 或 1，我们可以采取很多种做法，比如双端队列 bfs 或者最短路算法。

双端队列 bfs 本质上是 heap 优化的 dijsktra 特例。



## 多源汇最短路
1. floyd 算法
可以用来解决的问题有：
   1. 求多源汇最短路问题
   2. 传递闭包
   3. 找最小环
   4. 恰好经过 k 条边的最短路，倍增思想


floyd 算法又称 “插点法”，算法逻辑很简单，重要的是如何去证明它：
1. $d[i][j] = inf, d[i][i] = 0$
2. 三重循环枚举 n 个顶点，通过 $d[i][j] = min(d[i][j], d[i][k] + d[k][j])$ 进行更新


其思想是动态规划的思想。

1. 状态表示， $dp[k][i][j]$
   - 集合：所有从 i 出发，最终走到 j，且中间只经过结点编号不超过 k 的所有路径
   - 属性：路径长度的最小值
2. 状态计算：
   - 所有包含结点 k 的路径：我们通过 k 将路径 [i, j] 分成 [i, k] 和 [k, j]。两段只能含有 [1, k-1] 结点，因此：dp[k-1][i][k] + dp[k-1][k][j]
   - 所有不包含结点 k 的路径： $dp[k-1][i][j]$(只用编号为 [1, k-1] 的结点)


通过滚动数组进行优化，即得到 floyd 算法。




传递闭包：
如果两个点能够间接相连，那么我们对这两个点进行连一条边，这叫做原图的传递闭包。

可以直接通过 floyd 算法思路直接解决，证明方式同样使用动态规划来解决。



## 差分约束


## 最小生成树

1. prim 算法
算法过程如下：
1. 任取一个点为起点，设为 s，并将其加入已标记集合，设为 c。未标记点的集合设为 c1.
2. 从在 c1 中找到一个点，该点到集合 c 的距离最小，并将其加入到 c。
3. 重复步骤 2 共 n-1 次，得到了最小生成树

证明过程很简单，反证法即可：
如果步骤 2 取的最短距离两个点为 x, y。如果取得距离不是最小的（并且形成了最小生成树），那么我们在最后一定会有另外一条路径保证点 x 和 y 联通，那么这条路径和边 (x, y) 构成一条环，并且环上所有的边都大于等于 (x, y)。那么我们断开仍以一条边，那么整条环上的顶点仍然保持联通，并且不会增加最小生成树的代价。也就和我们的假设矛盾。

整个算法过程和 dijkstra 算法很像。

4. kruskal 算法
1. 排序所有的边
2. 遍历所有的边:
   - 如果边上的两个顶点 x, y 如果不连通，则将该边加入到最小生成树
   - 否则，不加入

证明过程同上。

**上面的两个算法是应用在无向图当中的。**






1. 朱流算法（有向图）


> n 个点， m 条无向边，边权可正可负。求连接所有顶点的最短路径和？

上面的问题无法通过最小生成树算法来解决。



**最小生成树的理论基础**：
1. 任意一棵最小生成树，一定**可以**包含无向图中权值最小的边（可以是因为权值最小的边可能不止一个）
2. 给定一个无向图 G = (V, E), n = |V|, m = |E|。从 E 中选出 k < n-1 条边构成 G 的一个生成森林。若再从剩余的 m - k 条边中选 n-1-k 条边添加到生成森林中，使其称为 G 的生成树，并且使选出的边的权值之和最小。则该生成树一定**可以**包含 m-k 条边中连接生成森林的两个不连通结点的权值最小的边。

prim 算法和 kruskal 算法都是对定理 2 的简单应用。


## 二分图



dp 一般可以转化为 拓扑序上的最短路问题。

