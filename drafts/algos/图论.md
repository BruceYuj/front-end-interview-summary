## 基本概念
1. 拓扑排序

拓扑排序对应着 DAG 图，也就是有向无环图。目的是将图中的所有顶点排成线性序列，使得途中任意一对顶点 $u$ 和 $v$, 如果 $<u, v> \in E$，则 u 在线性序列中必须出现在 v 之前。

扩展：
1. 只有 DAG 图才会有拓扑序
2. 对于一个 DAG，可能存在多个拓扑序

算法过程：
1. 建立图，统计每个顶点 v 的入度，将入度为 0 的所有元素入队
2. 循环取出对头元素，假设为 t
   - 将 t 发出的所有边对应的顶点入度减 1，如果当前顶点入度被减为 0，则将该顶点入队
3. 则出队的顺序就是拓扑排序。如果出队元素个数小于顶点个数，则表示图中有环，不存在拓扑序。

[acwing 848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)


## 单源最短路
1. 边权非负
   - 朴素 dijkstra，时间复杂度 $O(n^2)$
   - 堆优化的 dijkstra, 时间复杂度 $O(mlogm)$
2. 有负权边
   - bellman-ford: $O(nm)$
   - spfa: 平均 $O(m)$, 最坏 $O(nm)$

基础算法理解并不难，题目的难点在于如何将问题转化和抽象成对应的算法模型。

dijkstra 算法的基础核心是贪心，需要确保每个边权都是正的。

下面我们来看下具体的算法：
1. 假设 $d[i]$ 表示源点 1 到 i 的最短距离，初始化为无穷大。则 $d[1] = 0$，$vis$ 数组表示当前顶点是否已经被访问过。
2. 循环 n 次，在每次循环中：
   1. 查找未被访问的顶点中 $d[i]$ 最小的顶点，设为 t。则 $d[t]$ 此时的值即为$1 -> t$ 的最短距离。我们将 $vis[t]$ 标记为 true。
   2. 将 t 关联的边用三角不等式进行更新

为什么需要边权都是正的？

> 确保 dijkstra 算法贪心的正确性。按照 dijkstra 算法只要某个顶点被访问过，则该点到源点的最短距离就确定了。

[acwing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

我们仔细观察会发现，只有在第二步通过 **三角不等式** 进行松弛的时候才会更新 dist 数组。也就是说，只有松弛操作才会影响到最短距离。

因此，我们可以通过最小堆来维护所有的被更新的 $dist[i]$ 这样可以在 $O(1)$ 来获取此时最小的 $dist[i]$。总共更新次数最多是 $m$ 次，而在二叉堆中维护数据的成本是 $O(logn)$，因此松弛操作的复杂度为 $O(mlogm)$。

另外，找到当前没有标记且离源点最近的点的复杂度总共 n 次。因此时间复杂度由最大的决定，总共为 $O(mlogm)$

算法思路为：
1. 最小堆为 q，设 dist 维护 1 到 所有点的最短距离。$dist[1] = 0$,并将 $(dist[1], 1)$ 放入到 q 中。标记数组为 vis。
2. 弹出堆顶元素，设为 t：
   - 如果 t 已经被标记 ，continue
   - 标记 t，并且将 t 关联的所有顶点用三角不等式更新。如果有更新，对应的顶点放入到 q 中




### bellman ford
动态规划思想

bellman ford 算法思想很简洁。其本质是：在第 k 次循环中，所有源点到顶点的最短路径边长数 小于等于 k 的dist都会被更新完成。难点在于如何理解算法的正确性。

在 **算法导论** 当中，是通过数学归纳法来证明的，用到 松弛的收敛定理。

算法过程如下：
1. 循环 n-1 次
2. 每次循环当中，对 m 条边进行松弛操作

因此，时间复杂度为 $O(nm)$。

其可以用来判断是否存在负环：如果在第 n 次循环当中，仍然存在边可以进行松弛操作，那么一定存在负环。

因为进行 n 次循环后，可以找到一条最短路，路径上存在 n+1 个点，根据容斥原理，一定存在一个环，并且这个环减少了路径和，因此是负环。

[AcWing 853. 有边数限制的最短路 ](https://www.acwing.com/activity/content/problem/content/922/1/)
1. 进行 k 次循环，每次循环松弛所有的边。一定可以得出由源点出发经过 k 条边到达对应顶点的当前最短路径和。

避免同层循环互相影响，因此我们需要将 dist 数组进行复制处理。


### spfa 算法
spfa 是国内的叫法，在国际上，该算法被称为基于队列优化的 bellman ford 算法。

其思想是只有被三角不等式进行松弛的顶点才有可能影响到其它顶点。所以我们通过队列维护被更新过的顶点，每次只需要处理这些顶点即可。这样避免每次重复遍历未松弛的边。

其算法步骤为：
1. 设队列为 q，将源点 s入队，`vis[s]` 标记为 true
2. 弹出队头元素，设为 t:
   - `vis[t]` 设为 false，表示队列中没有 t 了
   - 处理 t 发起的每条边，如果某个顶点能够通过三角不等式进行松弛，设为 i，则将 i 放入到队列中，并标记 i
3. 循环进行步骤 2，直到队列为空

值得注意的是，spfa 算法可能会被通过数据构造卡掉。


> 我们可以通过 spfa 算法来判断是否存在负环。

常用方法：
1. 统计每个点的入队次数，如果某个点入队次数到达 n 次，则说明存在负环（没理解）
2. 统计每个点的最大短路中所包含的边数，如果某个点的最短路所包含的边数大于等于 n，也就是表明这条路径存在 n+1 个点，也就是表明存在环。如果该环是正的，那么我们可以去掉该环，得到一个更小的最短路，因此该环一定是负的。

朴素做法是：对于每个点进行一次 spfa，那么平均时间复杂度将达到 $O(nm)$，乘上常系数很容易超时。

更好的做法是，我们可以在原图的基础上增加一个虚拟源点，这样就将多源汇最短路转换成单源最短路问题。从虚拟源点向其他所有点建立一条边权为 0 的边，那么原图有负环等价于新图有环。


### 题目应用
1. [acwing 1127. 香甜的黄油](https://www.acwing.com/problem/content/1129/)

题目解析：
有 n 个点，m 条边。每个点可能有 $x \in [0, k]$ 个物品。选择任意一个点作为终点，那么将所有物品传递到该终点的最小代价和。

n 的范围是 800， m 的范围是 1450。

这里我们直接用朴素的想法即可。
1. 枚举所有的点，设为 i
2. 以 i 为起点，计算该点到其他点的最短距离。然后计算代价和
3. 答案即为所有代价和的最小值。

具体计算最短距离的算法我们可以采用：堆优化的 dijkstra 或者 spfa 都可。


2. [AcWing 1126. 最小花费](https://www.acwing.com/problem/content/1128/)
题目分析：

假设由 A 到 B 的路径构成一个集合。每个集合中的路径为 $x_1 x_2 ... x_k$

那么 $res * (1-x_1) * (1-x_2)... = 100$，我们期望 res 为这个集合当中的最小值。也就意味着我们期望 $(1-x_1) * (1-x_2) ....$ 最大。

而对于 $1- x_i$ 来讲其范围是 $(0, 1]$ 中间的小数。

我们由两种证明方式可以思考：
1. 直接通过 dijkstra 贪心思路来思考。每次选取到起点乘积最大的且未被访问的点加入即可，最后得到的答案就得到了所有点到起点的最大值。
2. 通过 $log(x_1*x_2) = logx_1 + logx_2$。也就是等价于：
   $logx_1 + logx_2 + ....$ 最大值。我们知道 log(x) 是单调递增的函数，并且在 (0, 1] 时恒小于等于 0。也就是期望 $log(1/x_1) + log(1/x_2)+...$ 最小。这样我们又变回了边权非负的最短路的解决问题。

这里我们采用第一种写法来做。比较方便。


3. [AcWing 920. 最优乘车](https://www.acwing.com/problem/content/922/)

题目分析：

从顶点 1 到 s 的换乘最小代价，等价于从 1 到 s 最少经过几条路线。

对于任意一条路线上的前后两点，表示 $i$ 和 $j$ 都会经过 1 条路线。那么我们可以将路线上任意两点连接一条权值为 1 的边。时间复杂度为 $O(M*N^2)$

那么问题就变成了从 1 到 s 的最短路径和。时间复杂度为 $O(N^2)$

因此，总时间复杂度为 $O(M*N^2)$

4. [acwing 903. 昂贵的聘礼](https://www.acwing.com/problem/content/905/)

题目分析：

题目要求买到最后的聘礼。
1. 10000 金币
2. 物品 + 8000 金币

而要弄到物品则需要同样的操作：
1. 金币
2. 物品 + 金币

我们会发现：
物品与物品之间有关系，形成一张图，而权值则是对应着兑换的折扣价。

那么初始化怎么处理呢？
假设我们初始时候一个物品都没有。我们可以通过建立一个虚拟源点，指向所有的物品，边权为物品的直接购买价格。

那么问题就转换成：从虚拟源点到终点的最短路径和。

题目还有额外一个限制条件：如果物品方的地位相差超过 M，那么不能进行交易。

对于限制条件最朴素的想法就是枚举：枚举所有不超过 M 的地位范围，并且该范围一定得包含物品 1 的地位，这样才能购买到 1.


### 综合应用
综合应用指的是 **最短路算法+其他算法** 的结合应用。

1. dfs + 最短路
[acwing 1135. 新年好](https://www.acwing.com/problem/content/1137/)

题目要求求出从 1 开始遍历完成所有的 a, b, c, d, e 车站。

遍历的顺序为 $5!$ 种可能。我们距离其中的一种情况：
$1-> a -> b -> c -> d -> e$

我们要分别求出 $1->a$ 、$a->b$... 等五段路的最短路。

思路 1： 我们求出任意两点间的最短路，使用 floyd 算法，时间复杂度 $O(n^3)$，超时。

思路 2：分别以 $a,b,c,d,e$ 为起点，求出起点到任意其他点的最短距离。$O(5*x)$， $x$ 为最短路算法的时间复杂度。这里我们可以采用 spfa 或者 heap 优化的dijkstra 算法都可。

1. 预处理出 a, b, c, d, e 五个点之间的所有最短路距离。
2. 枚举所有的走法即可。


--

2. [AcWing 340. 通信线路](https://www.acwing.com/problem/content/342/)

题意分析：
要求 1 - N 的所有路径当中第 k+1 大元素最小。而要求 **最大最小值** ，一般可以通过二分来解决。

我们二分可能的最小值，设为 x。判断是否存在一条路径，其大于 x 的边数是否大于 k：
- 如果大于 k，则 < x 的元素都不合法
- 如果小于等于 k，则 >= x 的元素都合法

而如何进行统计合法的边数呢？ 
1. 如果边的值 <= x,则权值为 0
2. 如果边的值 > x, 则权值为 1

则求 1 - n 的最短路径和即为所求的边数。在这里由于权重都为 0 或 1，我们可以采取很多种做法，比如双端队列 bfs 或者最短路算法。

双端队列 bfs 本质上是 heap 优化的 dijsktra 特例。


---

3. [AcWing 342. 道路与航线](https://www.acwing.com/problem/content/344/)

题意分析：
1. 有 R 条双向边，边权都为非负；有 R 条单向边，边权可正可负；求起点 s 到所有顶点的最短路。顶点范围为 25000, 边数范围为 $1.5 * 10^5$.
2. 题目确保，任意航线上两点不会走回头路。也就是说，单向边不会构成环。

按照基本的题意，我们可以直接通过 spfa 算法求解，问题在于该题的测试用例经过了特殊的构造，会专门卡掉 spfa 算法，因此我们只能通过其他方式求解。

因此我们需要结合第二个题目条件求解。
1. 我们只将双向边添加到图中，形成若干个连通块。
2. 把各个连通块看成一个个点（缩点），再将单向边添加到该图中，会形成一个 DAG。再有向无环图中，无论边权为正为负，都可以按照拓扑序进行扫描，在线性时间内求出单源最短路。

详细的算法过程：
1. 将双向边加入到图中，用深度优先遍历划分图中的连通块，并且记 $c[x]$ 为顶点 x 所在的连通块编号
2. 统计每个连通块的总入度，记为 $deg[i]$
3. 建立一个队列，存储连通块编号，用于拓扑排序，最初队列中包含所有入度为 0 的连通块. 设 $d[s] = 0,$ 其他为 inf。
4. 取出队头的连通块 i，对该连通块进行 heap 优化的 dijkstra 算法：
   1. 建立一个堆，将连通块 i 中的所有结点加入到堆中
   2. 从堆中取出 $d[x]$ 最小的节点 x
   3. 如果 x 被扩展过，堆到步骤 2，否则进入下一步
   4. 扫描从 x 出发的所有边 (x, y, z) 用 $d[x] + z$ 更新 $d[y]$ 
   5. 如果 $c[x] = c[y]$,表示扩展的点仍然在连通块内，并且 $d[y]$ 被更新，则将 y 插入堆
   6. 如果 $c[x] \neq c[y]$, 则令 $deg[c[y]] -= 1$, 如果为 0，则将 $c[y]$ 插入拓扑序列的队列尾部
   7. 重复 2-6 直到堆为空
5. 重复步骤 4，直到队列为空，拓扑排序完成
   
数组 d 即为所求，那么整个时间复杂度 $O(T+P+ RlogT)$


----

4. [acwing 341. 最优贸易](https://www.acwing.com/problem/content/343/)

题目分析：
1. 如果没有进行贸易，那么可以会赚取 0 元
2. 如果进行贸易，我们假设走动的路径为 $1 -> ... -> x -> ... -> n$。那么我们一定会在路径的前面一段购买东西，后面的一段卖东西。

也就等价于：枚举路径中所有可能经过的点，设为 x。求 $1->x$ 中的最小值 minV，求 $x->n$ 中的最大值 maxV，然后答案等于 $max(maxV, minV)$

那么如何求权值最小的路径中的点？
1. 能否通过 dijkstra 算法解决呢？
dijkstra 算法基于贪心思想。通常维护的是路径上的 sum 问题，并且要求每条边为非负的。而本题目中维护的 max/min 性质，不具有累加性，不能保证后面的数一定比前面大（这是dijkstra 能用贪心的根本原因）。

比如如果存在 $5->6->7->5$ 这样的环，那么刚开始更新了 $dmin[5] = 10$ 而 $7->5$ 为 3，那么 $dmin[5] = 3$，而通过 dijkstra 算法是更新不了的。类似于存在负数的情况。

因此，可以通过 spfa 算法解决。

后一段我们可以通过建立一个反向图，那么 $x->n$ 也就是变成了从 $n->x$ 中的最大值了。

这样我们就得到了答案。

解法2：
1. 预处理出 1 能够到达的所有点，存储起来，设为 back。
2. 我们将 dist[i] 全部初始化为水晶价格，并且全部放到 heap 当中：
   1. 弹出每个元素，看 1 能够到达边的起点，如果能够到达，则更新，这样就求出所有点的最小值了
3. 最大值同步骤 2




**为什么不能通过 dp 来解决？**
因为不一定时拓扑图，状态的更新可能存在环，也就是“有后效性”，因此不能使用。



## 多源汇最短路
1. floyd 算法
可以用来解决的问题有：
   1. 求多源汇最短路问题
   2. 传递闭包
   3. 找最小环
   4. 恰好经过 k 条边的最短路，倍增思想


floyd 算法又称 “插点法”，算法逻辑很简单，重要的是如何去证明它：
1. $d[i][j] = inf, d[i][i] = 0$
2. 三重循环枚举 n 个顶点，通过 $d[i][j] = min(d[i][j], d[i][k] + d[k][j])$ 进行更新


其思想是动态规划的思想。

1. 状态表示， $dp[k][i][j]$
   - 集合：所有从 i 出发，最终走到 j，且中间只经过结点编号不超过 k 的所有路径
   - 属性：路径长度的最小值
2. 状态计算：
   - 所有包含结点 k 的路径：我们通过 k 将路径 [i, j] 分成 [i, k] 和 [k, j]。两段只能含有 [1, k-1] 结点，因此：dp[k-1][i][k] + dp[k-1][k][j]
   - 所有不包含结点 k 的路径： $dp[k-1][i][j]$(只用编号为 [1, k-1] 的结点)


通过滚动数组进行优化，即得到 floyd 算法。




传递闭包：
如果两个点能够间接相连，那么我们对这两个点进行连一条边，这叫做原图的传递闭包。

可以直接通过 floyd 算法思路直接解决，证明方式同样使用动态规划来解决。



## 差分约束


## 最小生成树

1. prim 算法
算法过程如下：
1. 任取一个点为起点，设为 s，并将其加入已标记集合，设为 c。未标记点的集合设为 c1.
2. 从在 c1 中找到一个点，该点到集合 c 的距离最小，并将其加入到 c。
3. 重复步骤 2 共 n-1 次，得到了最小生成树

证明过程很简单，反证法即可：
如果步骤 2 取的最短距离两个点为 x, y。如果取得距离不是最小的（并且形成了最小生成树），那么我们在最后一定会有另外一条路径保证点 x 和 y 联通，那么这条路径和边 (x, y) 构成一条环，并且环上所有的边都大于等于 (x, y)。那么我们断开仍以一条边，那么整条环上的顶点仍然保持联通，并且不会增加最小生成树的代价。也就和我们的假设矛盾。

整个算法过程和 dijkstra 算法很像。因此，我们同样可以通过 heap 来优化整个 prim 算法，那么时间复杂度为 $O(mlogm)$，复杂度和 kruskal 算法相似，但是代码比它复杂。

4. kruskal 算法
   1. 排序所有的边
   2. 遍历所有的边:
      - 如果边上的两个顶点 x, y 如果不连通，则将该边加入到最小生成树
      - 否则，不加入

证明过程同上。

**上面的两个算法是应用在无向图当中的。**


1. 朱流算法（有向图）


> n 个点， m 条无向边，边权可正可负。求连接所有顶点的最短路径和？

上面的问题无法通过最小生成树算法来解决。



**最小生成树的理论基础**：
1. 任意一棵最小生成树，一定**可以**包含无向图中权值最小的边（可以是因为权值最小的边可能不止一个）
2. 给定一个无向图 G = (V, E), n = |V|, m = |E|。从 E 中选出 k < n-1 条边构成 G 的一个生成森林。若再从剩余的 m - k 条边中选 n-1-k 条边添加到生成森林中，使其称为 G 的生成树，并且使选出的边的权值之和最小。则该生成树一定**可以**包含 m-k 条边中连接生成森林的两个不连通结点的权值最小的边。

prim 算法和 kruskal 算法都是对定理 2 的简单应用。


### 题目应用
1. [acwing 1142. 繁忙的都市](https://www.acwing.com/problem/content/1144/)

题目分析：
1. 没有重边，无向图，要求选取一些边，将所有顶点连通起来，并且边数最少

分析得出，要让所有顶点都联通起来，至少需要 n-1 条边，也就是形成一棵树。

2. 要求该树中的权值最大值尽量的小

本身最小生成树的两个算法求的是权值之和最小的数，那么该思路是否能够求权值最大值最小的情况呢？

答：同样可以。证明和 kruskal 算法的证明一样。
1. 假设没有选择当前可选择的最小边，那么一定会选择比当前的最小边权值更大的边，并且能够和最小边形成一个环，随意断开一条边，再加上最小边，那么最终的结果一定不会比之前更大。因此就可以证明了。

2. [acwing 1143.联络员](https://www.acwing.com/problem/content/description/1145/)

本题使用了 **最小生成树** 的第二个基本定理。也就说去除一些固定的边，再剩下的边中求最小代价生成一棵树，仍然可以使用 kruskal 的算法求取。具体证明过程同上。

3. [AcWing 1144. 连接格点](https://www.acwing.com/problem/content/1146/)
本题和第二题思路是一样的，只是在预处理数据时候稍微复杂一点。
- 映射矩阵中的所有点到整数，共有 nm 个点
- 由于边长固定为 1 或 2，因此我们可以将纵向边先加入，然后再统一加入横向边

时间复杂度为 $O(nm)$，统计边的复杂度。


4. [AcWing 1146. 新的开始](https://www.acwing.com/problem/content/1148/)
题目分析：
本题是经典的虚拟源点+最小生成树的题目。虚拟源点技巧在图论中是经常被使用的技巧之一。

假设存在一个虚拟源点，其向所有矿井连一条边，边权代价为在该矿井上建立发电站的代价 $v_i$。求整个图的最小生成树。


## 二分图



dp 一般可以转化为 拓扑序上的最短路问题。

