## 基本概念
1. 拓扑排序

拓扑排序对应着 DAG 图，也就是有向无环图。目的是将图中的所有顶点排成线性序列，使得途中任意一对顶点 $u$ 和 $v$, 如果 $<u, v> \in E$，则 u 在线性序列中必须出现在 v 之前。

扩展：
1. 只有 DAG 图才会有拓扑序
2. 对于一个 DAG，可能存在多个拓扑序

算法过程：
1. 建立图，统计每个顶点 v 的入度，将入度为 0 的所有元素入队
2. 循环取出对头元素，假设为 t
   - 将 t 发出的所有边对应的顶点入度减 1，如果当前顶点入度被减为 0，则将该顶点入队
3. 则出队的顺序就是拓扑排序。如果出队元素个数小于顶点个数，则表示图中有环，不存在拓扑序。

[acwing 848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/)


## 单源最短路
1. 边权非负
   - 朴素 dijkstra，时间复杂度 $O(n^2)$
   - 堆优化的 dijkstra, 时间复杂度 $O(mlogm)$
2. 有负权边
   - bellman-ford: $O(nm)$
   - spfa: 平均 $O(m)$, 最坏 $O(nm)$

基础算法理解并不难，题目的难点在于如何将问题转化和抽象成对应的算法模型。

dijkstra 算法的基础核心是贪心，需要确保每个边权都是正的。

下面我们来看下具体的算法：
1. 假设 $d[i]$ 表示源点 1 到 i 的最短距离，初始化为无穷大。则 $d[1] = 0$，$vis$ 数组表示当前顶点是否已经被访问过。
2. 循环 n 次，在每次循环中：
   1. 查找未被访问的顶点中 $d[i]$ 最小的顶点，设为 t。则 $d[t]$ 此时的值即为$1 -> t$ 的最短距离。我们将 $vis[t]$ 标记为 true。
   2. 将 t 关联的边用三角不等式进行更新

为什么需要边权都是正的？

> 确保 dijkstra 算法贪心的正确性。按照 dijkstra 算法只要某个顶点被访问过，则该点到源点的最短距离就确定了。

[acwing 849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/)

我们仔细观察会发现，只有在第二步通过 **三角不等式** 进行松弛的时候才会更新 dist 数组。也就是说，只有松弛操作才会影响到最短距离。

因此，我们可以通过最小堆来维护所有的被更新的 $dist[i]$ 这样可以在 $O(1)$ 来获取此时最小的 $dist[i]$。总共更新次数最多是 $m$ 次，而在二叉堆中维护数据的成本是 $O(logn)$，因此松弛操作的复杂度为 $O(mlogm)$。

另外，找到当前没有标记且离源点最近的点的复杂度总共 n 次。因此时间复杂度由最大的决定，总共为 $O(mlogm)$

算法思路为：
1. 最小堆为 q，设 dist 维护 1 到 所有点的最短距离。$dist[1] = 0$,并将 $(dist[1], 1)$ 放入到 q 中。标记数组为 vis。
2. 弹出堆顶元素，设为 t：
   - 如果 t 已经被标记 ，continue
   - 标记 t，并且将 t 关联的所有顶点用三角不等式更新。如果有更新，对应的顶点放入到 q 中








## 多源汇最短路


## 差分约束


## 最小生成树

## 二分图



dp 一般可以转化为 拓扑序上的最短路问题。

