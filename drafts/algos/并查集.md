## 并查集
通常有两种操作：
1. find(x) - 查找集合的父节点
2. union(a,b) - 合并集合 a 和 b

两种优化技巧：
1. 路径压缩 - $O(logn)$
2. 按秩合并 - $O(logn)$

两个都用的话，反阿克曼函数

在并查集的应用当中，通常有两个技巧：
1. 记录每个集合大小 - 绑定在父元素上
2. 记录每个元素和父元素的距离 - 绑定在每个元素上

食物链：
- 扩展域的解法：枚举思想
- 带边权的解法：

[1579. 保证图可完全遍历](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)


### 应用 1
1. [acwing 1250. 格子游戏](https://www.acwing.com/problem/content/1252/)

看似是一个困难的博弈论问题，其实我们发现还是一个集合问题。

每一次连边，表示将边上的两个端点代表的两个集合合并成一个。
如果连边时发现，两个端点已经在一个集合当中，表示这次连边一定能形成一个环，游戏结束。

也就抽象成基本问题：动态合并集合，并且判断两点是否在同一集合当中。

时间复杂度 $O(mlogn)$


2. [acwing 1252. 搭配购买](https://www.acwing.com/problem/content/1254/)

从题意可以看出：
1. 所有可以搭配的云构成不同的集合，买集合中的任意一个东西，必须将整个集合都买下来，整个集合的价格和价值即是里面单个元素的总和。

=》那么问题就变成了：有 k 个集合元素，有 w 的背包容量，求最大可获得价值，也就是 01 背包问题。时间复杂度 $O(kw)$

那么如何快速在 M 次构造中得到所有集合元素的价值和价格呢？
=》很容易就想到通过并查集来解决上面的问题。$O(mlogn)$

总体的复杂度满足题目数据范围要求。



3. [acwing 237. 程序自动分析](https://www.acwing.com/problem/content/239/)

本题简化成抽象语言就是：
1. 将每个约束条件的两边看成是两个元素，相等表示元素之间有边，不等表示两个元素没有通路。那么如何判断矛盾呢？

只需要将相等的约束条件关系全部建立完成，然后判断不相等的元素是不是出现在已经建立的图当中存在通路。

我们可以通过图论来解决上面的问题。但是通过图论来解决是有点“大炮打蚊子”。

由于约束条件只有两种关系，那么我们同样可以通过并查集来维护元素之间的关系：
如果两个元素在同一个集合内，那么这两个元素满足相等关系，如果在，则不满足。

这样我们可以在 $O(nlogn)$ 建立好约束条件，可以在 $O(nlogn)$ 内判断是否矛盾。所以总体时间复杂度为 $O(t*nlogn)$，满足要求。

小问题：由于 i, j 的范围是 $10^9$，如果直接开数组会导致空间问题。而我们发现 n 的范围是 $10^6$, 也就是说最多存在 $2*10^6$ 个元素，因此我们需要进行离散化（这里之间通过hash 进行无序的离散化即可）

4. [acwing 238. 银河英雄传说](https://www.acwing.com/problem/content/240/)

如果不问两者之间的间隔，那么就是一个简单的并查集，动态添加中来判断两个元素是否在一个集合当中。那么我们该如何来解决间隔问题呢？

这里，我们使用并查集应用当中的第二个技巧：
1. 每个元素维护到父节点的距离。那么元素 i 和 j 之间的距离就是 $max(abs(d[i] - d[j])-1, 0)$

那么问题就回到了我们该如何维护 $d$ 呢？

假设集合 $i$ 接到集合 $j$ 当中，表示 $i$ 中的所有点的距离都需要加上 $size[j]$，也就是 $j$ 中元素的个数。

朴素做法是直接给 $i$ 中每个元素都加上 $size[j]$，这样的时间复杂度会达到 $O(n^2)$，因此需要优化：

我们可以直接将 $i$ 集合的根节点的 $d[i]$ 加上 $size[j]$ 即可。这样我们在合并后求 $i$ 结点到根节点的距离可以递归加起来。

问题 1：由于本身我们在 并查集 中使用路径压缩，元素的父节点会不断改变（也就是说集合的存储不是单链式的），那么 $d$ 的存储还是正确的吗？

是正确的，我们可以在 $find()$ 方法里面在路径压缩的时候同时处理 $d$ 方法即可。
