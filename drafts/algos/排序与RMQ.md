## 排序 

### 七夕祭
要想解决 **七夕祭** 问题，我们先来看一个经典的简化问题，也就是 **环形均分纸牌问题**。

[acwing 122. 糖果传递](https://www.acwing.com/problem/content/124/)（环形均分纸牌的简化版就是均分纸牌问题：[acwing 1538. 均分纸牌](https://www.acwing.com/problem/content/description/1538/)）

第一个明显的结论是：如果 $sum(a[i])$ 不能整除 n，一定不存在解。

[图：ipad 算法系列图解 - p12-14]

$x_i$ 表示 $a_i 和 a_{(i+1)\%n}$ 的传递关系：
1. $a_i$ 给 $a_{(i+1)\%n}$ 个 $x_i$ 个糖果, $x_i$ 为负时表示传递关系相反



那么代价为 $abs(x_1) + ... + abs(x_n)$


求无序数组的中位数可以用 **求第 k 小的数 - quickSelect 算法来求**，平均时间复杂度 $O(n)$


我们再来分析 **七夕祭** 的问题：
要使每行的糖果个数相同，每列的个数相同。我们仔细观察会发现，行操作和列操作是相互独立的。那么问题就转换成两个独立的 **环形均分纸牌问题**。

算法就简单了起来。

### 动态中位数
朴素做法： 每次到奇数个时，进行排序，得到中位数即可。

$O(p(3log3+5log5+ .... + nlogn))$ 时间复杂度肯定是超时的。

一个非常高效的做法是维护两个堆 - 小顶堆和大顶堆

1. 小顶堆中的所有元素都 大于等于 大顶堆中的元素
2. 大顶堆大小 等于 `小顶堆大小` 或者 `大小+1`

那么中位数就是大顶堆的堆顶元素。

那么时间复杂度就是：
$O(p(log1+log2+log3+log4+ ... + n/2*log(n/2))) = O(pn/2*log(n/2))$

### 超快速排序
根据题意，其本质是一个冒泡排序，叫我们求最少的交换次数。

1. 每交换一次相邻数据，就会减少一个逆序对。而本地就是求数组中逆序对的数量，可以通过归并排序来求。



## RMQ

区间最大值/最小值问题 - 本质是一个动态规划
st表

缺点在于不能修改(这是算法竞赛中的)。

$f[i][j]$ 表示从下表 $i$ 开始连续 $2^j$ 个元素的最大值。
$[i, i+2^j-1]$ 可以分为两个 $2^{j-1}$ 个元素的区间： $[i, i+ 2^{j-1}-1]$ 和 $[i+2^{j-1}, i+2^j-1]$。
也就是 $f[i][j-1]$ 和 $f[i+2^{j-1}][j-1]$

$f[i][j] = max(f[i][j-1], f[i+2^{j-1}][j-1])$

类似于区间 dp 的求法。

```python
import math

if __name__ == "__main__":
    n = int(input())
    
    a = list(map(int, input().split()))
    m = int(math.log(n, 2))

    f = [[float("-inf")]*(m+1) for i in range(n)]
    
    for i in range(m+1):
        for j in range(n-(1<<i)+1):
            if i == 0:
                f[j][i] = a[j]
            else:
                f[j][i] = max(f[j][i-1], f[j + (1 << (i-1))][i-1])
    
    t = int(input())

    while t:
        t -= 1
        
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        le = b-a+1
        x = int(math.log(le, 2))
        
        print(max(f[a][x], f[b-(1<<x)+1][x]))
                

```


预处理的时间复杂度为 $O(nlogn)$
查询的时间复杂度为 $O(1)$





