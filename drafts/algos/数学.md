
[leetcode 483. 最小好进制](https://leetcode-cn.com/problems/smallest-good-base/)

求最小进制 k，使得 $k^0+k^1+ ... + k^m = n$

**解法一：数学+二分法**

随着 k 增大，长度 m 会变小。假设 k = 2，那么$m = log_2{n+1}-1$, 由于 $n \in [3, 10^18]$，那么 $m \leq 60$

那么，我们可以枚举长度 m 来判断合适的 k 是多少？

已知， $k \geq 2$, 当长度为 2 时， $k = n-1$，也就是说 $k \in [2, n-1]$ 之间。

朴素做法，对于每个 m，从小到大枚举 k 是否是答案？ 时间复杂度为 $O(m^2n)$,超时。

仔细观察，会发现，对于固定的长度 m，$k \in [2, n-1]$ 是具有二分性的。

设中间点为 mid, $check(x) = x^0 + x^1 + ... x^m$:
- 如果 $check(mid) \geq n$, 那么 $check(x) \geq n, x \in (mid, n-1]$ ，可以缩减右边界
- 如果 $check(mid) < n$，那么 $check(x) < n, x \in (2, mid]$，可以缩减左边界

这样将时间复杂度降低到 $O((logn)^3)$, 约 $10^5$ 级别。

> 在 python 中 $1o^{18}$ 不会整数溢出，因此可以直接转换成整数比较。在其他语言中，直接字符串比较即可-先比较长度，再比较单个字符。


解法二：**数学** - 二项式定理

$n = k^0 + k^1 + ... + k^m < k^m$

$(k+1)^m = C_m^0*k^0 + C_m^1*k^1 + ... + c_m^m*k^m > n$ => $(k+1)^m > n > k^m$ => $k < \sqrt[m]{n} < k+1$

那么对于不同的 m，可以在 $O(1)$ 求得对应的 k（如果对于该长度 m， k 存在的话）。

总时间复杂度为 $(logn)^2$


