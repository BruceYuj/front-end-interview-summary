
## 下一个排列
[leetcode 31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

下一个排列在 C++ 中右专门的 next_permutation 方法，其主要目的是获取当前字典序当中下一个更大的排序。

具体该如何做呢？

将排列分成 `左边+右边`, 左边是不变的部分，右边是变化的部分。自然是期望左边越长越好。

如何变化右边呢？假设右边第一个数是 a, 期望找到右边其他的数中最小比 a 大的数，然后两者交换，最后将 a 的右边重新升序排列，就得到了下一个排列。

那么我们如何保证左边最长呢？

贪心做法。倒序比较， 找到第一个 $a[i] < a[i+1]$ 的位置，$[i+1, n]$ 是降序排列。$a[i]$ 就是可以被用来交换的较小的数，在 $[i+1, n]$ 中找到最小的大于 它的数，设为 j

交换 $a_i, a_j$，且交换后 $[i+1, n]$ 仍然保持降序。

因此，只需要将 $[i+1, n]$ 反序一下及得到了答案。

时间复杂度为 $O(n)$, 平均复杂度为 $O(1)$
 