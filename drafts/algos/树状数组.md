


## 树状数组
通过数组来模拟树形。为什么不直接建树？因为没有必要。

**解决问题**：可以解决大部门基于区间上的更新和求和问题（前缀和）。

**和线段树的区别：**
1. 常系数更小
2. 树状数组解决的问题可以由线段树解决。

**优缺点**：
1. 动态修改和查询的复杂度都是 $O(logN)$

**变式**：
1. 单点更新+单点查询：传统数组即可
2. 单点更新+区间查询：树状数组 or 线段树
3. 区间更新+单点查询：差分（查询的复杂度是 $O(n)$，如果想要查询复杂度降低到 $O(logn)$，可以使用 差分+树状数组）
4. 区间更新+区间查询：差分+树状数组


```python
def lowbit(x):
    return x & (-x)

def add(x, k):
    i = x
    while i <= n:
        c[i] += c
        i += lowbit(i)

def sum(x):
    i = x
    res = 0
    while i:
        res += c[i]
        i -= lowbit(i)
    
    return res
```

我们来仔细分析下树状数组的代码：
1. `lowbit(x)` 求出 x 的二进制表示的从最后一位开始计算，连续 0 的长度（也就是最后一位 1 所在的位置）

树状数组利用的是二进制的思想，这类思想贯穿算法的学习，我们知道任何一个数 $x$ 根据二进制的分解定理得出：$x = 2^{k_1} + 2^{k_2} + ... + 2^{k_m}$，因此我们就可以将区间 $[1, x]$ 分解为 $logx$ 个区间。

我们设 $k_1 > k_2 > .... > k_m$:
1. 长度为 $2^{k_1}$ 的小区间为 $[1, 2^{k_1}]$
2. 长度为 $2^{k_2}$ 的小区间为 $[2^{k_1} +1 , 2^{k_1}+2^{k_2}]$
3. ....
4. 长度为 $2^{k_m}$ 的小区间为 $[2^{k_1} + 2^{k_2} + ... + 2^{k_m-1}+1, 2^{k_1} + 2^{k_2} + ... + 2^{k_m}]$

假设上述的小区间的结尾为 $R$, 那么区间长度就等于 $R$ 的二进制分解下最小 2 的次幂，也就是 $lowbit(R)$。
比如 $7 = 2^2 + 2^1 + 2^0$,那么分解的三个区间就是：
1. $[1, 4] = lowbit(4)$
2. $[5, 6] = lowbit(6)$
3. $[7, 7] = lowbit(7)$

树状数组就是基于上述思想的数据结构，其基本作用是**维护序列的前缀和**。

对于给定的序列 a，我们构建一个序列 c，其中 $c[x] = [x-lowbit(x)+1, x]$ 。这样我们就得到了 sum 方法，可以在 $log(n)$ 时间求得前缀和。

树状数组的第二个作用是**单点更新**，也即是在更新序列 a 中的数的同时正确维护序列的前缀和。即得到了 add 方法，可以在 $log(n)$ 时间内完成更新操作。


在执行所有操作前，我们得完成树状数组的初始化，也即是得到正确的 c。通常由两种方式：
**建树的方式**：
1. $O(nlogn)$: `for(i = 1; i <= n; i ++) add(i, a[i])`
类似于差分建立差分数组的技巧。直接建立一个全为 0 的数组 c，然后对每个位置 x 进行 `add(x, a[x])` 即可。

2. $O(n)$: 通过求每个结点直接儿子来做。两种方式：
    - `for(i = x-1; i >= x - lowbit(x) + 1; i -= lowbit(i)) c[x] += c[i]`
    - 先求出所有的前缀和；在通过定义直接求出每一个 $C[i]$ 

> 为什么 $O(nlogn)$ 的初始化建树复杂度满足要求。因为一般用树状数组解决的问题都是由动态更新操作，这类题目的朴素做法的复杂度一般达到 $O(n^2)$，所以数据范围不是那么变态。

### 常见应用 1： 值域上建立树状数组
给定一个集合 a，我们用 $t[val]$ 保存 val 在集合 a 中出现的次数。那么 $t[l,r]$ 的区间和就表示集合 a 中范围在 $[l, r]$ 内的数有多少。这样我们在集合中插入或删除一个数，同样可以在 $logn$ 的时间复杂度进行统计。

#### 求逆序对的数量
解法一：通过归并排序求，时间复杂度 $O(nlogn)$, 分治思想

解法二：树状数组求。
1. 在序列 a 的数值范围内建立树状数组，初始化为全 0
2. 倒序扫描给定的序列 a，对于每个元素 a[i]:
   1. 在树状数组中查询前缀和 $[1, a[i]-1]$, 累加到答案中
   2. 执行 **单点添加** 操作，即把树状数组中 $a[i]$ 位置上的数加 1 (`t[a[i]] += 1`),同时维护树状数组
3. res 即为答案

> 思考：是否一定要倒序？不一定，如果正序做的话，我们统计`[a[i]+1, maxV]` 的前缀和。倒叙的目的是知道每个数后面比它小的有多少。时间复杂度为 $O((N+M)logN)$, $M$ 为数值范围的大小。如果数值范围较大，可以通过有序离散化预处理，不过这样就过于麻烦了。


题目 1. [acwing 241. 楼兰图腾](https://www.acwing.com/problem/content/243/)

朴素做法：
1. 设 v 图腾和 ^ 图腾答案分别为 res1, res2
1. 枚举每一个位置，设为 $k$
    1. 分别计算 $k$ 左边小于 $a[k]$ 和大于 $a[k]$ 的元素个数，设为 11, 12
    2. 分别计算 $k$ 右边小于 $a[k]$ 和大于 $a[k]$ 的元素个数，设为 r1, r2
    3. res1 += l2 * r2, res2 += l1 * r1

那么时间复杂度为 $O(n^2)$，会超时。

那么有没有办法快速的知道每个位置 k 左边和右边相对元素的个数呢？
时间复杂度在 $O(1)$ 或者 $O(logn)$ 即可。

这里就是经典的 **在值域上进行树状数组** 的应用。
1. 设 v 图腾和 ^ 图腾答案分别为 res1, res2
2. 初始化树状数组 $t1[1, n]$ 为 0。数组 a1 和 a2 表示左边小于和大于位置元素。
3. 正序枚举每一个位置，假设为 k：
    1. 快速计算 $[1, a[k]-1]$ 范围的前缀和，表示左边小于 $a[k]$ 的元素个数，记录在 a1 中
    2. 计算 $[a[k]+1, n]$ 的区间和，表示左边大于 $a[k]$ 的元素个数，记录在 a2 中
    3. 将 (a[i], 1) 更新到树状数组中
4. 初始化 t1[1, n] 为 0。倒序枚举每一个位置，假设为 k，类似于第三步统计元素并和结果相加即可。

题目 2 - [acwing 242. 一个简单的整数问题](https://www.acwing.com/problem/content/248/)
1. 指令 1 是进行 **区间加法**
2. 指令 2 是求多个 **区间加法** 后某个位置的值

这是 **差分** 的标准模板，将区间加法转换成 **单个元素加法**。问题在于转换成差分数组后，要求某个位置的值需要进行求前缀和。而原始前缀和的时间复杂度为 $O(n)$。那么整体的最坏复杂度为 $O(nm)$。

因此，需要改进，而我们发现树状数组可以将求元素和的时间复杂度降低到 $O(logn)$，符合数据范围要求。

题目 3 - [acwing 243. 一个简单的整数问题2](https://www.acwing.com/problem/content/244/)
1. 指令 1 是进行 **区间加法**
2. 指令 2 是求多个 **区间加法** 后区间和

指令 2 变化后，如果按照题目 2 的解法，时间复杂度达到 $O(nlogn)$，总体时间复杂度达到 $O(nmlogn)$，超时。该如何解决呢？

我们需要做一个性质的观察：
题目 2求某一个位置的值为 $\Sigma_{i=1}^{x}b[i]$，到题目 3 中变成：
$\Sigma_{i=1}^{x}\Sigma_{j=1}^{i}b[j] = \Sigma_{i=1}^{x}(x-i+1)*b[i] = (x+1)\Sigma_{i=1}^{x}b[i] - \Sigma_{i=1}^{x}i*b[i]$ 

这可以通过图形来观察得到：[算法图例-p16]

这样我们需要维护两个树状数组 t1, t2.

题目 4 - [acwing 244. 谜一样的牛](https://www.acwing.com/problem/content/245/)

$a_i$ 表示 $i$ 前面有多少头比它低的牛。由于牛的身高是 $[1, n]$。

朴素做法是什么？
1. 初始化数组 $a[1,n]$ 表示当前身高是否已经找到牛，初始化为 1
2. 倒叙枚举每一个 $i$。（正序是没有办法处理的）：
    1. 统计剩下元素中第 $h[i]+1$ 小的元素,设为 x，即为第 i 个位置的身高
    2. 将 $a[x]$ 置为 0

时间复杂度为 $O(n^2)$

有没有办法降低时间复杂度呢？
要求第 k 小的元素，而每个元素各自都是不相同的。那么我们可以建立 $[1, n]$ 值域的树状数组，这样我们可以在 $logn$ 求出某一个数的前缀和。

要求第 k 小的元素，我们可以不断统计 $[1, n]$ 元素的个数，而元素是满足单调性的。

举例来说，
1. 如果 $[1, x]$ 中元素个数大于 k，那么对于 [1, x+1] 的元素个数一定也大于 k。
2.  如果 $[1, x]$ 中元素个数小于 k，那么对于 [1, x-1] 的元素个数一定也小于 k。

因此，我们可以在统计元素个数时对树状数组进行二分。时间复杂度为 $(log(n)) ^ 2$,总时间复杂度为 $O(n*logn*logn)$




## reference
1. https://www.cnblogs.com/xenny/p/9739600.html
2. https://www.zhihu.com/question/54404092
3. https://www.acwing.com/solution/content/13818/