## 线段树
线段树属于一种基于分治思想的二叉树结构，用来存储区间或者线段信息。相比于树状数组，线段树更加通用：

1. 线段树的每个结点表示一个区间。根节点唯一，并且代表的区间时整个统计范围，比如 $[1, N]$
2. 线段树的每个叶子结点表示一个长度为 1 的元区间 $[x, x]$
3. 对于每个内部结点 $[l, r]$, 其左子节点为 $[l, mid]$, 右子节点为 $[mid+1, r]$, $mid = math.floor(l+r >>1)$

按照这种构造方式，除了最后一层之外，剩下的二叉树是一棵满二叉树，树的深度是 $O(logN)$。如果使用基础建树的方式来建立线段树，整个代码会显得很复杂。此时，更具二叉堆建立技巧，我们可以使用数组来模拟线段树，数组下标就是指针。
- 根节点的编号是 1
- 结点 x 的左子节点编号是 2x, 右子节点编号是 2x+1. 父节点编号是 x/ 2.
- 这样， N 个叶子结点的满二叉树有 $N + N/2 + N/4 + ... + 1 = 2N - 1$，而在实际线段树可能会多一层，因此，往往我们开数组长度为 $4N$ 来避免数组越界。（可以通过离散化来压缩空间）


### 应用
线段树通常解决的问题：
1. 在线更新和查询区间信息：比如区间的最值、区间和、最大子区间和
   - 单点修改 + 区间查询
   - 区间修改 + 单点查询
   - 区间修改 + 区间查询
   - 区间最大子段和
   - 区间内某个值是否出现过
   - 区间连续空的长度
   - 区间最长上升子序列
   - 矩阵面积求并
   - 区间染色+单次统计
   - 区间染色+批量统计
   - 多色矩阵面积并
   - 区间第 K 大
   - 最值维护



2. push up
3. push down : 懒标记、延迟标记
4. 扫描线

通常一个线段树的实现有四个方法：
1. pushup() / pushdown()
2. build()：将一个区间初始化为线段树
3. modify(): 修改单点 / 修改区间
4. query(): 查询区间信息



例题 1. [acwing. 1275. 最大数](https://www.acwing.com/problem/content/1277/)

题目有两种操作：
1. 往序列后面添加一个数，该数是 $(t+a) \  mod \ p$, 而 $a$ 是上一次查询答案或者为 $0$
2. 询问操作：当前序列中最后 $L$ 个数中的最大数

朴素做法是：枚举每次操作即可。查询的时间复杂度是 $O(mL)$，因此可能超时。

仔细思考我们会发现：
1. 往序列后面添加一个数，其实是将该数从 0 进行更新
2. 询问操作：假设当前元素个数为 n，查询当前 $[n-L+1, n]$ 范围内的最大值

这是经典的 **在线单点更新+区间查询** ，可以通过线段树来完成。

在这里有两种写法：
1. 经典的递归版本
2. 非递归版本，常系数更小一些（zkw 线段树）

参考资料：
1. https://codeforces.com/blog/entry/18051
2. https://blog.csdn.net/zearot/article/details/48299459
3. https://wenku.baidu.com/view/aa520b17773231126edb6f1aff00bed5b9f373ea.html?rec_flag=default&fr=pc_newview_relate-1001_1-1-wk_rec_doc2-1001_1-2-aa520b17773231126edb6f1aff00bed5b9f373ea&sxts=1617874738711

