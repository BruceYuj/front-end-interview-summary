从运行时、包以及编译器架构都有了很多的改进。架构分层更加清晰，好处是：
1. 维护更加方便
2. 编译器的功能被扩展


## composition API
本身一直存在 Vue 响应式系统当中，但是在 Vue 3.0 会将其从底层暴露给上层用户。这样可以给用户的一些高级用例提供更加灵活的逻辑组织方式。

## Fragment Teleport suspense

## vite 
本意是 proof-of-concept。但是发现很有潜力，就扩展了开来。

vite 本身不需要任何编译，只有当请求到达服务器时候才会编译（保留原生 ES module 的写法）。

当前页面中引用多少就编译多少，比较适合于大项目。因为大项目有几十个路由，每个路由里面有很多的组件，如果全部编译一遍，会很有耗时。

但是需要注意的是，vite 是 dev 环境用来辅助开发的。发布时候仍然需要使用 rollup 来帮助我们打包。

rollup 在处理懒加载分包是用的原生的 es module, 也就是说仍然是预设你的环境支持原生的 es module。但是 es module 是可以被 polyfilled（dynamic import）。




vite 和 vue 并没有强绑定，虽然对 vue 的支持会更好。但是同样可以使用在 react 里面（react-fast-refresh）。

vite 的热加载基本是瞬间的。而 webpack 的热重载仍然需要 几秒。

vite 的理念是更 开箱即用。 ESBuild（比官方的 tsc 性能要好几十倍）



## 如何体验 VUE3
1. vite
2. webpack preview
3. vue-cli


> mpvue 的维护的问题是把整个 Vue 都 fork 了一遍（weex 是在 vue 官方的里面），因此 vue 将 compiler 抽象出来，这样方便 做一些独立性的使用。


vue 2 创建一个实例的开销很大，主要是由于每次都需要往 this 上面暴露很多东西。并且这些暴露的属性都是使用的 `Object.defineProperty` 去定义的（computed，props）。

vue 3 基于 proxy，就可以把一些属性定义给丢掉，然后暴露给渲染函数。而获取属性时由 proxy 动态返回给你（提前已经知道你想要的东西）

vue 2， template -> virtual dom。这个对于性能上有很大浪费的一个地方就是，当有动态、静态结合的模板时，virtual dom 不会区分，而是所有的都进行 diff。
而我们本身语法就有模板这一层，因此我们可以避免上面的情况。在模板这一块进行静态分析，生成比较聪明的渲染函数。能提升到静态结点的就不需要进入渲染函数了，也就不需要再创建一遍结点。

根据 v-if / v-for 将结点抽象成粒度更粗的 block。
vue 2 里面也有类似的优化，但没有 vue 3 那么极致。也就是说我更多的去考虑模板里面动态的部分。时间复杂度降低了一个数量级。

vue3 的服务端编译和客户端编译时完全不一样的。SSR 编译的策略就是能静态字符串化的全部静态化。在 Vue2中也有类似的优化，但是是在后期加入的，并且仍然需要以 virtual dom 的一个结点表示。vue 3 渲染器是重写的，有优化模式和非优化模式，优化模式下，当前组件纯字符串化后，就只有一个 buffer，渲染的时候只是往 buffer 里面推字符串（不需要虚拟节点了），在渲染过程中，遇到某一个组件发现如果没有 SSR Render 的这个（用户手写了渲染函数或者没有使用服务端去编译），就退回到原有的基于 virtual dom 再去字符串化的模式。

vue3 很好的优化了异步并行的能力。（小尤写的很得意的地方，服务端渲染）

性能计算 - 需要注意是否去掉 DOM 操作的固定时间。在 CPU 利用上面达到什么样的地步。

vue3 在动静比越夸张的时候性能越高（而且在实际的业务开发时，动静比是比较大的）